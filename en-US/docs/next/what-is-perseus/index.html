<!DOCTYPE html><html lang=en-US class=light><head><base href=https://framesurge.sh/perseus/><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1.0"><link rel=stylesheet href=.perseus/static/tailwind.css><link rel=stylesheet href=.perseus/static/styles/style.css><script type=module>window.__PERSEUS_RENDER_CFG = `{"docs/next/faq":"docs","docs/0.3.4/reference/testing/fantoccini-basics":"docs","docs/0.3.0-0.3.3/debugging":"docs","docs/0.3.4/reference/deploying/docker":"docs","docs/0.4.x/fundamentals/routing":"docs","docs/next/core-principles":"docs","docs/state/manual":"docs","docs/0.4.x/intro":"docs","docs/0.3.4/reference/strategies/amalgamation":"docs","docs/0.2.x/strategies/incremental":"docs","docs/0.4.x/first-app/installation":"docs","docs/0.3.0-0.3.3/hello-world":"docs","plugins":"plugins","docs/0.3.4/reference/state/rx":"docs","docs/next/fundamentals/debugging":"docs","docs/0.3.4/reference/cli":"docs","docs/0.3.4/reference/strategies/build-paths":"docs","docs/next/first-app/error-handling":"docs","docs/0.1.x/strategies/build_state":"docs","docs/0.1.x/arch":"docs","docs/0.3.4/reference/ejecting":"docs","docs/0.3.0-0.3.3/deploying/size":"docs","docs/0.3.4/advanced/subsequent-loads":"docs","docs/0.3.0-0.3.3/plugins/control":"docs","docs/0.3.0-0.3.3/testing/checkpoints":"docs","docs/fundamentals/routing":"docs","docs/0.3.4/reference/plugins/writing":"docs","docs/0.3.4/reference/server-communication":"docs","docs/0.4.x/first-app/dev-cycle":"docs","docs/0.4.x/state/incremental":"docs","docs/0.3.4/reference/index-view":"docs","docs/0.1.x/tutorials/first_app/setup":"docs","docs/0.4.x/core-principles":"docs","docs/0.3.4/reference/strategies/intro":"docs","docs/fundamentals/plugins":"docs","docs/0.3.0-0.3.3/strategies/build-state":"docs","docs/0.4.x/fundamentals/perseus-app":"docs","docs/0.3.4/reference/plugins/security":"docs","docs/next/fundamentals/preloading":"docs","docs/next/fundamentals/head-headers":"docs","docs/state/freezing-thawing":"docs","docs/0.3.0-0.3.3/strategies/amalgamation":"docs","docs/0.3.0-0.3.3/i18n/intro":"docs","docs/0.2.x/strategies/revalidation":"docs","docs/0.4.x/capsules/capsules-vs-components":"docs","docs/0.4.x/first-app/generating-pages":"docs","docs/0.3.0-0.3.3/plugins/using":"docs","docs/0.4.x/fundamentals/hydration":"docs","docs/0.3.4/reference/plugins/control":"docs","docs/0.2.x/i18n/translations-managers":"docs","docs/next/fundamentals/styling":"docs","docs/0.4.x/state/revalidation":"docs","docs/0.2.x/deploying/exporting":"docs","docs/0.2.x/what-is-perseus":"docs","docs/next/fundamentals/plugins":"docs","docs/0.3.0-0.3.3/deploying/serverful":"docs","docs":"docs","docs/0.3.0-0.3.3/advanced/subsequent-loads":"docs","docs/0.3.4/reference/deploying/serverless":"docs","docs/next/state/amalgamation":"docs","docs/0.4.x/fundamentals/error-views":"docs","docs/next/fundamentals/i18n":"docs","docs/0.4.x/state/amalgamation":"docs","docs/0.3.4/reference/debugging":"docs","docs/0.3.4/reference/styling":"docs","docs/next/state/incremental":"docs","docs/0.3.4/reference/i18n/defining":"docs","docs/fundamentals/serving-exporting":"docs","docs/faq":"docs","docs/0.3.0-0.3.3/testing/fantoccini-basics":"docs","docs/0.4.x/state/suspense":"docs","docs/0.2.x/testing/intro":"docs","docs/0.3.0-0.3.3/updating":"docs","docs/state/revalidation":"docs","docs/0.3.4/advanced/intro":"docs","docs/0.2.x/i18n/intro":"docs","docs/next/state/build":"docs","docs/fundamentals/error-views":"docs","docs/0.3.4/reference/plugins/using":"docs","docs/0.2.x/templates/intro":"docs","docs/0.4.x/state/intro":"docs","docs/0.2.x/styling":"docs","docs/0.3.0-0.3.3/deploying/intro":"docs","docs/0.4.x/fundamentals/head-headers":"docs","docs/0.4.x/fundamentals/compilation-times":"docs","docs/next/migrating":"docs","docs/first-app/defining":"docs","docs/0.3.0-0.3.3/what-is-perseus":"docs","docs/next/first-app/installation":"docs","docs/0.2.x/testing/manual":"docs","docs/0.3.4/tutorials/hello-world":"docs","docs/capsules/capsules-vs-components":"docs","docs/0.3.4/reference/i18n/intro":"docs","docs/0.3.4/reference/hydration":"docs","docs/0.4.x/capsules/intro":"docs","docs/0.3.4/reference/templates/setting-headers":"docs","docs/first-app/deploying":"docs","docs/0.2.x/i18n/using":"docs","docs/state/suspense":"docs","docs/0.4.x/state/freezing-thawing":"docs","docs/0.2.x/strategies/intro":"docs","docs/0.3.0-0.3.3/ejecting":"docs","docs/0.3.4/reference/testing/intro":"docs","docs/next/fundamentals/static-content":"docs","docs/fundamentals/compilation-times":"docs","docs/0.3.4/reference/updating":"docs","docs/0.3.0-0.3.3/intro":"docs","docs/next/fundamentals/hydration":"docs","docs/0.3.0-0.3.3/deploying/serverless":"docs","docs/0.3.0-0.3.3/views":"docs","docs/0.3.0-0.3.3/testing/intro":"docs","docs/0.3.0-0.3.3/templates/metadata-modification":"docs","docs/0.3.4/reference/live-reloading":"docs","docs/0.3.0-0.3.3/pitfalls-and-bugs":"docs","docs/0.3.4/reference/perseus-app":"docs","docs/0.1.x/building":"docs","docs/0.4.x/what-is-perseus":"docs","docs/0.3.0-0.3.3/strategies/intro":"docs","docs/fundamentals/hydration":"docs","docs/0.2.x/intro":"docs","docs/next/intro":"docs","docs/state/incremental":"docs","docs/0.2.x/advanced/routing":"docs","docs/fundamentals/static-content":"docs","docs/0.3.4/reference/deploying/size":"docs","docs/0.3.0-0.3.3/advanced/routing":"docs","docs/0.3.4/reference/static-content":"docs","docs/0.3.4/reference/snooping":"docs","docs/0.1.x/error_pages":"docs","docs/0.3.4/reference/state/hsr":"docs","docs/0.4.x/quickstart":"docs","docs/0.3.0-0.3.3/strategies/request-state":"docs","docs/0.2.x/strategies/build-state":"docs","docs/0.2.x/i18n/defining":"docs","docs/0.3.4/reference/state/global":"docs","docs/fundamentals/reactor":"docs","docs/next/state/global":"docs","docs/0.3.0-0.3.3/strategies/revalidation":"docs","docs/0.2.x/i18n/other-engines":"docs","docs/0.3.0-0.3.3/plugins/security":"docs","docs/0.1.x/strategies/request_state":"docs","docs/0.3.4/advanced/route-announcer":"docs","docs/fundamentals/preloading":"docs","docs/0.4.x/first-app/error-handling":"docs","docs/0.4.x/fundamentals/styling":"docs","docs/next/fundamentals/serving-exporting":"docs","docs/first-app/error-handling":"docs","docs/0.4.x/state/manual":"docs","docs/next/state/intro":"docs","docs/0.1.x/strategies/revalidation":"docs","docs/0.3.4/tutorials/second-app":"docs","docs/0.3.4/reference/engines":"docs","docs/0.3.4/reference/views":"docs","docs/0.3.4/reference/exporting":"docs","docs/next/state/helper":"docs","docs/0.3.0-0.3.3/static-content":"docs","docs/0.3.4/reference/define-app":"docs","docs/0.4.x/fundamentals/serving-exporting":"docs","docs/0.4.x/fundamentals/static-content":"docs","docs/0.1.x/strategies/build_paths":"docs","docs/0.3.4/reference/templates/intro":"docs","docs/0.1.x/templates":"docs","docs/next/state/browser":"docs","docs/0.4.x/fundamentals/js-interop":"docs","docs/next/first-app/deploying":"docs","docs/state/browser":"docs","docs/0.2.x/second-app":"docs","docs/0.1.x/tutorials/first_app/template":"docs","docs/0.3.4/reference/strategies/incremental":"docs","docs/0.4.x/capsules/using":"docs","docs/0.3.0-0.3.3/templates/setting-headers":"docs","docs/0.1.x/strategies/incremental":"docs","docs/0.3.0-0.3.3/exporting":"docs","docs/next/first-app/dev-cycle":"docs","docs/first-app/dev-cycle":"docs","docs/0.3.0-0.3.3/cli":"docs","docs/0.2.x/advanced/initial-loads":"docs","docs/0.4.x/state/helper":"docs","docs/0.3.0-0.3.3/error-pages":"docs","docs/0.2.x/static-content":"docs","docs/fundamentals/styling":"docs","docs/0.3.4/reference/i18n/translations-managers":"docs","docs/0.1.x/tutorials/first_app/app":"docs","docs/0.1.x/tutorials/first_app/intro":"docs","docs/0.4.x/first-app/deploying":"docs","docs/0.3.0-0.3.3/plugins/writing":"docs","docs/0.3.0-0.3.3/plugins/tinker":"docs","docs/0.3.4/reference/state/freezing":"docs","docs/next/state/manual":"docs","docs/0.3.4/tutorials/auth":"docs","docs/0.3.0-0.3.3/styling":"docs","docs/0.4.x/fundamentals/reactor":"docs","docs/0.3.0-0.3.3/i18n/other-engines":"docs","docs/0.3.0-0.3.3/i18n/defining":"docs","docs/0.2.x/strategies/build-paths":"docs","docs/0.3.0-0.3.3/server-communication":"docs","docs/0.2.x/strategies/amalgamation":"docs","docs/0.3.0-0.3.3/plugins/publishing":"docs","docs/0.2.x/error-pages":"docs","docs/0.4.x/fundamentals/preloading":"docs","docs/next/quickstart":"docs","docs/0.4.x/state/build":"docs","docs/migrating":"docs","docs/0.3.0-0.3.3/hydration":"docs","docs/0.3.0-0.3.3/advanced/initial-loads":"docs","docs/0.3.4/reference/plugins/publishing":"docs","docs/next/capsules/intro":"docs","docs/0.2.x/testing/fantoccini-basics":"docs","docs/next/fundamentals/perseus-app":"docs","docs/0.2.x/views":"docs","docs/0.3.0-0.3.3/i18n/using":"docs","docs/0.2.x/ejecting":"docs","docs/state/intro":"docs","docs/0.4.x/state/request":"docs","docs/next/what-is-perseus":"docs","docs/core-principles":"docs","docs/0.3.0-0.3.3/stores":"docs","docs/0.1.x/setup":"docs","docs/0.3.4/intro":"docs","docs/first-app/generating-pages":"docs","docs/0.3.0-0.3.3/advanced/define_app":"docs","docs/0.4.x/fundamentals/debugging":"docs","docs/fundamentals/perseus-app":"docs","docs/capsules/intro":"docs","docs/0.2.x/updating":"docs","docs/0.4.x/fundamentals/testing":"docs","docs/0.3.4/core-principles":"docs","docs/0.3.4/reference/templates/metadata-modification":"docs","docs/0.2.x/advanced/subsequent-loads":"docs","docs/0.3.4/reference/i18n/other-engines":"docs","docs/0.3.4/reference/state/idb-freezing":"docs","docs/0.3.4/reference/deploying/relative-paths":"docs","docs/what-is-perseus":"docs","docs/0.2.x/hello-world":"docs","docs/next/fundamentals/compilation-times":"docs","docs/0.4.x/state/browser":"docs","docs/0.3.4/reference/strategies/revalidation":"docs","docs/0.3.0-0.3.3/advanced/arch":"docs","docs/0.4.x/faq":"docs","docs/0.3.4/reference/plugins/functional":"docs","docs/0.2.x/templates/metadata-modification":"docs","docs/state/amalgamation":"docs","docs/next/first-app/generating-pages":"docs","docs/quickstart":"docs","docs/0.3.0-0.3.3/advanced/intro":"docs","docs/next/capsules/using":"docs","docs/0.4.x/fundamentals/i18n":"docs","":"","docs/0.3.0-0.3.3/templates/intro":"docs","docs/next/fundamentals/js-interop":"docs","docs/0.4.x/first-app/defining":"docs","docs/0.3.0-0.3.3/deploying/docker":"docs","docs/0.3.0-0.3.3/plugins/intro":"docs","docs/intro":"docs","docs/0.3.4/reference/deploying/intro":"docs","docs/0.2.x/cli":"docs","docs/fundamentals/i18n":"docs","docs/0.3.4/what-is-perseus":"docs","docs/next/fundamentals/testing":"docs","docs/next/fundamentals/routing":"docs","docs/0.4.x/state/global":"docs","docs/0.3.4/reference/strategies/request-state":"docs","docs/0.2.x/config-managers":"docs","docs/0.3.4/reference/pitfalls-and-bugs":"docs","docs/0.3.0-0.3.3/second-app":"docs","docs/0.3.4/advanced/arch":"docs","docs/fundamentals/testing":"docs","docs/state/request":"docs","docs/next/fundamentals/reactor":"docs","docs/0.1.x/strategies/intro":"docs","docs/0.3.4/reference/testing/manual":"docs","docs/next/state/revalidation":"docs","docs/fundamentals/js-interop":"docs","docs/next/capsules/capsules-vs-components":"docs","docs/0.2.x/deploying/intro":"docs","docs/0.3.0-0.3.3/plugins/functional":"docs","docs/capsules/using":"docs","docs/0.3.4/reference/error-pages":"docs","docs/0.2.x/debugging":"docs","docs/0.4.x/fundamentals/plugins":"docs","docs/next/fundamentals/error-views":"docs","docs/0.3.4/reference/templates/router-state":"docs","docs/0.3.0-0.3.3/testing/manual":"docs","docs/0.3.4/reference/stores":"docs","docs/0.1.x/serving":"docs","docs/0.3.4/reference/i18n/using":"docs","docs/state/helper":"docs","docs/0.3.0-0.3.3/strategies/build-paths":"docs","docs/0.2.x/templates/setting-headers":"docs","docs/0.4.x/migrating":"docs","docs/0.3.0-0.3.3/define-app":"docs","comparisons":"comparisons","docs/next/first-app/defining":"docs","docs/0.3.0-0.3.3/strategies/incremental":"docs","docs/0.3.4/reference/testing/checkpoints":"docs","docs/0.3.4/reference/plugins/tinker":"docs","docs/0.1.x/config_managers":"docs","docs/0.1.x/integrations/actix-web":"docs","docs/fundamentals/debugging":"docs","docs/next/state/suspense":"docs","docs/state/build":"docs","docs/0.2.x/testing/checkpoints":"docs","docs/next/state/request":"docs","docs/next/state/freezing-thawing":"docs","docs/0.3.0-0.3.3/deploying/relative-paths":"docs","docs/0.2.x/define-app":"docs","docs/0.3.4/reference/plugins/intro":"docs","docs/first-app/installation":"docs","docs/0.2.x/advanced/intro":"docs","docs/fundamentals/head-headers":"docs","docs/0.3.0-0.3.3/i18n/translations-managers":"docs","docs/0.1.x/routing":"docs","docs/0.2.x/advanced/arch":"docs","docs/0.1.x/cli":"docs","docs/0.1.x/intro":"docs","docs/0.3.4/advanced/routing":"docs","docs/0.3.0-0.3.3/snooping":"docs","docs/0.3.4/advanced/initial-loads":"docs","docs/0.3.4/reference/strategies/build-state":"docs","docs/0.3.4/reference/deploying/serverful":"docs","docs/0.2.x/strategies/request-state":"docs","docs/state/global":"docs"}`;

        import init from "https://framesurge.sh/perseus/.perseus/bundle.js";
        async function main() {
            await init("https://framesurge.sh/perseus/.perseus/bundle.wasm");
        }
        main();

        
        

window.__PERSEUS_GLOBAL_STATE = `null`;</script><meta itemprop=__perseus_head_boundary><title>What is Perseus? | Perseus Docs</title><link rel=stylesheet href=.perseus/static/styles/markdown.css><link rel=stylesheet href=.perseus/static/styles/docs_links_markdown.css><link rel=stylesheet href=.perseus/static/prism.css><script>
window.__PERSEUS_INITIAL_STATE = `{"content":"<h1>What is Perseus?</h1>\\n<p>Perseus is a <strong>web development framework</strong> for the <strong>Rust</strong> programming language that focuses on the <strong>state</strong> of your app. Since there are three main ways you might approach Perseus, we'll break down each one individually here.</p>\\n<h2>You're familiar with Rust</h2>\\n<p>We can obviously agree that Rust is much better than JavaScript: it's way faster, strongly-typed, has a great compiler, and a fantastic package management system. In the browser, it runs <em>amazingly</em>. This is because of <a href=\\"https://webassembly.org\\">WebAssembly</a> (abbreviated <em>Wasm</em>), which is basically an assembly language for programs like Chrome, Firefox, etc. With it, you can compile your Rust code to run in the browser, and even access browser APIs, allowing you to display content to the user. In the past, Rust has been used with Wasm to perform things like heavy cryptography, but Perseus lets you exile JS completely, and run your whole site with Rust only.</p>\\n<p>Now, you might have come across other web development libraries and frameworks for Rust before, but there's a big difference between those two terms, so let's sort that out first. A <em>library</em> is a piece of code that you use to help you build your site. A <em>framework</em> is a mammoth of code that uses your code to build your site. Think of it like the difference between <code>futures::executor::block_on</code> and <code>#[tokio::main]</code>: one is being used by you to handle a bit of <code>async</code>, and the other is using your code to handle <em>all</em> the <code>async</code>. In the same way, a library is a great choice for when you want to build a small site, or when you want to replace just part of a site with Rust. For these kinds of things, we absolutely recommend <a href=\\"https://github.com/sycamore-rs/sycamore\\">Sycamore</a>, on which Perseus is based.</p>\\n<p>However, sometimes you'll need to break out the big guns. Sometimes, you'll need to render content in advance so that your users see it straight away, rather than a blank page while your Wasm boots up. Sometimes, you'll want to have a <em>stateful</em> app. This doesn't just mean you've got buttons and forms, etc., but that you're building your app in a special kind of pattern, which Perseus is built around. Let's say you have a simple static blog: you might have a <code>/post</code> URL, under which all your posts can be found. Fundamentally, all these posts have the same structure, just with different titles, dates, tags, and contents, so you might choose to create some kind of <em>template</em> for them, and then maybe build a Markdown parser or the like to push all that into your app to create <em>pages</em>. Essentially, <strong>template + state = page</strong>. In Perseus, this is all handled for you, and you just create templates, like <code>/post</code>, along with ways to render their state.</p>\\n<p>For example, for a blog, you might create a new post template with <code>Template::build(&quot;post&quot;)</code>, and then create a function that takes in some state and plugs it into a Sycamore <code>view! { .. }</code> to render some content. You might take in a <code>struct</code> containing contents, titles, tags, etc. If you then specify a function that can list the pages that this template should create (e.g. by getting all the Markdown files in a certain directory), and then another one that takes each path and generates state for it, Perseus will string it all together and give a lightning-fast app.</p>\\n<p>Beyond this, Perseus has all sorts of extra features, like inbuilt error handling systems that allow you to gracefully display error messages if state generation fails, or if your app panics, or something else like that. All you do is match an <code>enum ClientError</code>, and Perseus shows your errors to the client. Beyond that, if you want to build an app in multiple languages, Perseus will let you do it straight away: just replace the text in your code with identifiers inside the <code>t!()</code> macro, and define a map of translation IDs to text for each language you want to support. Variable interpolation is supported out of the box, and you can unleash the full power of <a href=\\"https://projectfluent.org\\">Fluent</a> for handling pluralization rules, genders, etc.</p>\\n<p>Going even further, Perseus' state generation platform is built for even the most advanced use-cases: let's say you have not a blog, but an ecommerce site selling a thousand products. Well, a thousand would actually build very quickly, so perhaps a million. Still probably looking at less than a second, but we'll go with it. Maybe you don't want to build all that at build time. Simple! Just add <code>.incremental_generation()</code> to your template definition and then...you're done. If a user goes to a product page that doesn't exist yet, it will be passed to your state generation functions, and, if it's a page that exists, those functions can produce the page, and Perseus will serve it. For any future users, that page will be cached and returned immediately. It's like building your whole app over time, on-demand. And, if you have an index of all your products, you could automatically <em>revalidate</em> that every, say, 24 hours, to make sure users have a fairly up-to-date listing. Or you could logic-based revalidation that checks each time whether or not there are actually any new products, before rebuilding. You could even combine the two: only check every few hours whether or not there are new products, and, if there are, rebuild that page.</p>\\n<p>To be clear, and this is important if you aren't familiar with web development, Perseus is not a library, it's a framework. It's a giant engine into which you plug your code that will connect everything together and optimize it, producing a super-fast site that outperforms every JS framework under the sun. It might well seem like you don't need a lot of these features, and, if you don't, you can just run <code>perseus export</code> to get a series of static HTML files that you can serve to users however you like, with a simple Wasm bundle making sure whatever interactivity you have works as smoothly as possible (and it will still be unreasonably fast). If you're used to systems programming, the whole idea of a framework might seem a bit absurd, but it's very often required in web development, simply because the best experiences come from complex features, like rendering your site to HTML in advance, or caching transactions, or delayable capsules that can be infinitely nested to create lazy-loaded pages, etc. Some of these are easy to implement, others are not. The point of Perseus is to handle this all for you so you can get on with what you want to write: your app. Even better, Perseus is built on <a href=\\"https://github.com/sycamore-rs/sycamore\\">Sycamore</a>, which handles reactivity primitives, meaning there is a separation of concerns, unlike with other current Rust frameworks: one team is in charge of the reactivity, and another in charge of the framework, meaning more features are developed more quickly, and bugs are fixed more rapidly, while both systems remain fantastically maintained.</p>\\n<p>If Perseus doesn't sound like your cup of tea, there are several other Rust frameworks you might like to check out: <a href=\\"https://github.com/sycamore-rs/sycamore\\">Sycamore</a> is the library on which Perseus is based, if you want to keep the same sort of style; <a href=\\"https://yew.rs\\">Yew</a> is a very popular library; and <a href=\\"https://seed-rs.org\\">Seed</a> is another. There's also <a href=\\"https://github.com/ivanceras/sauron\\">Sauron</a>, <a href=\\"https://github.com/MoonZoon/MoonZoon\\">MoonZoon</a>, and <a href=\\"https://github.com/leptos-rs/leptos\\">Leptos</a>, just to name a few. If you'd like to see some more in-depth comparisons between these projects, check out <a href=\\"comparisons\\">the comparisons page</a>.</p>\\n<h2>You're familiar with JavaScript, and you've know what NextJS, ReactJS, etc. mean</h2>\\n<p>Alright, you're pretty familiar with what web development is, and why we tend to need frameworks to make things simple and to remove the need to write hundreds of lines of boilerplate code for features we use in every app. But you've probably got plenty of questions about Perseus.</p>\\n<h3>Why Rust?</h3>\\n<p>Put simply, JS is <a href=\\"https://medium.com/netscape/javascript-is-kinda-shit-im-sorry-2e973e36fec4\\">a bit of a mess</a>. It's dynamically-typed, and executed at runtime, meaning you can't really catch bugs while you're coding. Sure, an IDE helps with this by showing you squiggly red lines, but it still won't stop you from forgetting about passing a certain argument to a function. TypeScript helps with this by introducing stricter typing rules, but it's really an addition on top of already existing JavaScript, and, let's be honest, how many times have you had to search up solutions for getting your <code>tsconfig</code> to work?</p>\\n<p><a href=\\"https://rust-lang.org\\">Rust</a>, on the other hand, is generally thought of as a systems programming language, meaning it's much lower-level and closer to the hardware, letting you do things like memory management more manually. It's certainly got a much steeper learning curve, but, let's walk through a quick example. Imagine you have a variable <code>data</code> that contains a very large amount of information. Obviously, copying this is going to slow your program down, so we want to avoid that if possible. In JS, you could do something like this:</p>\\n<pre><code class=\\"language-javascript\\">const data = &quot;...&quot;;\\nlet valid = isDataValid(data);\\nlet useful = isDataUseful(data);\\n</code></pre>\\n<p>You might not realize it, but this code could copy the whole of <code>data</code> under certain conditions, because, when you think about it, both <code>isDataValid()</code> and <code>isDataUseful()</code> need it. In fact, depending on your code's structure, JS might even implicitly copy this whole variable <em>twice</em>! This is an oversimplification, and there's a lot more going on here, but, in Rust, you have total control over this:</p>\\n<pre><code class=\\"language-rust\\">let data = get_data();\\nlet valid = is_data_valid(&amp;data);\\nlet useful = is_data_useful(&amp;data);\\n</code></pre>\\n<p>Here, we're passing <em>references</em> to <code>data</code> to those functions, which are like telling them where <code>data</code> can be found in memory, rather than giving them it's actual value. Again, we're oversimplifying, but the point is that Rust allows you much lower-level control over your data, and it's a compiled language, meaning you have to build your code into an executable, rather than just running it. In this stage, the compiler goes over your code with a fine-toothed comb, finding whole classes of bugs and making them impossible at runtime. And, to make things even better, <em>undefined behavior</em>, a special type of bug in C/C++/etc. (which often leads to <code>Segmentation fault</code> messages, which you might have seen before), is literally impossible in Rust, because the whole language is built on a clear boundary between <em>safe</em> code, and <em>unsafe</em> code. The latter might cause UB, and should explicitly clarify what has to be upheld for it to all work properly. Then, if code can be certain that it's upholding the necessary invariants, it can call itself safe. Basically, where the compiler can't prove that your code won't crash and burn, you explicitly have to, and there's no getting around it.</p>\\n<p>To illustrate just how powerful this model of programming is, let's take a bit of a meta-example. When we were building Perseus v0.4.0, we had to rewrite the entire Perseus core, over 12,000 lines of code. After innumerable cycles of changing some code and seeing errors pop up in the terminal, when we got all the errors fixed and the code actually compiled, the first time we ran <code>perseus build</code>, <em>it worked</em>. No logic bugs, no syntax errors, it just worked. <em>That</em> is the kind of power you get from working with Rust. (and absolutely ludicrous speeds.)</p>\\n<p>Usefully, the Rust compiler supports compiling for different <em>targets</em>, which are basically formats of machine code. Your Rust code can be turned into code that will run on Linux, macOS, Windows, etc. Or, it could run in the browser, through a revolutionary new technology called <a href=\\"https://webassembly.org\\">WebAssembly</a>, abbreviated as <em>Wasm</em>. Technically, any language, like C or C++, could compile into this format, but Rust has the added guarantees of <em>safety</em>.</p>\\n<p>Oh, and did we mention that Rust is <a href=\\"https://medium.com/@xpf6677/40x-faster-we-rewrote-our-project-with-rust-120b006c6abe\\">insanely fast</a>?</p>\\n<p>When you combine that with Wasm, a Rust site is usually &gt;30% faster than the equivalent site built in JavaScript, in terms of runtime performance. And, when we say &gt;30%, we mean &gt;90% on anything modern that's not running Safari (Apple being a bastion of implementing web standards, as usual).</p>\\n<p>With all this, Rust is the perfect language to implement a next-generation web framework in, and that's exactly what Perseus is.</p>\\n<h3>Okay, but what <em>is</em> it?</h3>\\n<p>As NextJS is to ReactJS, Perseus is to <a href=\\"https://github.com/sycamore-rs/sycamore\\">Sycamore</a>. Sycamore is a low-level reactive library for building websites in Rust that uses <em>no virtual DOM</em>, making it <a href=\\"https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html\\">faster than Svelte</a> in some cases (with improvements on the horizon to get <em>even faster</em>), and Perseus builds on these foundations to create a framework designed to make your life easier by minimizing boilerplate.</p>\\n<p>Assuming you're familiar with a few terms from the usual JS jargon about frameworks, let's run through Perseus' features. It supports static site generation (building your app to HTML before it's even running), server-side rendering (building pages at request-time based on user details, like cookies), client-side rendering (fetching data in the browser to render components), using SSG and SSR <em>on the same page</em> (which, to our knowledge, no other framework in the world supports), revalidation (allowing you to rebuild a page that was built originally at build-time, based on either timing or custom logic), incremental generation (rendering a page at request-time the first time it's requested, and then caching it for future use so it can be returned instantly next time), and <a href=\\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\\"><em>capsules</em></a>.</p>\\n<p>This is all based around <em>state</em>, because that's the focus of Perseus. Unashamedly, Perseus focuses on supporting highly complex apps with many moving parts and interconnected components. Of course, if you want to build a static blog, that's a piece of cake.</p>\\n<p>Fundamentally, Perseus boils down to a state framework, and, really, the whole idea of actually displaying content to a user is secondary. As far as Perseus is concerned, your state is generated in almost any way conceivable, it gets to the user, it's made <em>reactive</em> of its own accord (meaning, if you're coming from React, that any state you generate on the server comes to you already in a <code>useState()</code> hook), and then you can work with it however you like to display it to users (that's <a href=\\"https://github.com/sycamore-rs/sycamore\\">Sycamore</a>'s job). If your site isn't interactive (like a static blog), you can use unreactive state instead, no problem.</p>\\n<p>Based on this, Perseus' rendering model comes down to <em>templates</em>, which are like stencils for creating pages. For example, you might have a blog post template at the <code>post</code> URL, which would have the basic structure that all blog posts share. When you plug in the data of an individual blog post called <code>foo</code>, you get out that template, filled in with that state, to produce <code>post/foo</code>, a page.</p>\\n<p>In essence, <strong>template + state = page</strong>, that's the fundamental equation of Perseus.</p>\\n<p>But, we went further than this. If you're familiar with <a href=\\"https://astro.build\\">Astro</a>, then you'll have heard of the <em>islands architecture</em>, where you split your app into components that can individually render, hydrate, etc. Now, things are a bit different over here in Wasm-world, because things are so fast here that we don't really have to care about delaying hydration, or things like that, because it all happens just about instantly. Instead, our main concern is minimizing the amount of <em>stuff</em> (i.e. HTML and Wasm) that needs to be sent to the user's browser, because that's the real bottleneck for us. So, if you split out a complex ecommerce page into, say, a <em>widget</em> (Perseus' term for islands) for each product on your home page, then your home page can load as a simple skeleton waiting for some content. It's kind of like a template waiting for state, but the pieces that need to be filled in are actual mini-pages themselves. In fact, unlike any other framework ever created, Perseus has the unique concept that <strong>capsule + state = widget</strong>. That's right, as a template creates pages, a capsule creates widgets, meaning you can have a <code>product</code> capsule that incrementally generates product widgets as they're requested. You can use every single rendering strategy that works for pages on widgets, and you can control exactly when they're rendered too. If you want, say, the first row of products on your website's landing page to be instantly rendered, and then the rest to be lazy-loaded in parallel, you can do that by chaining <code>.widget()</code> to <code>.delayed_widget()</code>. It's that simple. Oh, and <em>everything</em> is cached by Perseus at the application-level, taking single-page routing into the world of caching and ensuring that users can literally <em>instantly</em> navigate back to any pages they've visited in the past.</p>\\n<p>Naturally, Perseus also comes with the usual stew of extra framework features, like internationalization out of the box that just works (translator APIs etc. are all available for you, and you can pick a really powerful one using <a href=\\"https://projectfluent.org\\">Fluent</a> or a really tiny one using JSON, with more to come), and one-command deployment to a <code>pkg/</code> folder that you put literally anywhere that runs executables. And if you want a static site, you just run <code>perseus export</code>, and you're set.</p>\\n<p>As for the Lighthouse scores, Perseus achieves 100 on desktop without even trying, and consistently above 90 on mobile. The dropoff in mobile performance is mostly because of the way mobile browsers still have to go in optimizing Wasm, but this will improve with time, and any user on a modern smartphone will see a snappy and responsive site practically instantly. That whole idea of render-then-hydrate is baked into Perseus: your users see content straight away, and it becomes reactive a moment later.</p>\\n<p>Unfortunately, the idea of <em>resumability</em>, as pioneered by <a href=\\"https://qwik.builder.io\\">Qwik</a>, isn't really possible with Wasm yet, because you actually can't split a Wasm bundle into smaller pieces, you just send the whole thing to the user. While that does mean that Perseus apps are <em>insanely</em> fast when going between pages, it can mean slightly slower load times when a user first comes to your site. That said, it's still 100 on Lighthouse, so it can't be <em>that</em> bad. Even so, we're sure you've had that bad experience of loading a site and trying to press buttons that don't work, and knowing (as a developer) that it's because the site hasn't hydrated yet. Now, with Perseus, your users really won't be waiting too long for those buttons to be working, but you can enable a feature flag that holds user interactions in stasis until your app is hydrated, before automatically re-sending them, leading to a much better overall user experience. And, if you don't like it, you can just turn it off.</p>\\n<p>The other really cool thing about Perseus is <em>error handling</em>. A lot of JS frameworks have this concept of <em>error boundaries</em>, but still more leave all the error management to you. If JS blows up (as it frequently does), you're left to clean up on your own. In Rust, errors have to be propagated explicitly with a type called <code>Result</code>, which can either be <code>Ok</code> or <code>Err</code>. Unless a function <code>panic!</code>s, it can't rip the floor out from under you and cause everything to fail. That means Perseus can handle nearly all errors gracefully: for example, if a single widget can't render its contents properly, it will automatically render an error instead. If Perseus can't start up your app, but it knows the user can already see some content, it will show a popup error message instead of replacing the perfectly good static content. And, if your whole app panics, crashing and burning to the ground, Perseus gives you the opportunity to run arbitrary code (like crash analytics) as well as display a nice error message to the user. And, because Rust is strongly-typed, if you forget to explicitly handle (or not handle) a particular type of error, your app just won't compile, and you'll get a lovely error message from the compiler. Basically, it would take an alignment of cosmic rays flipping dozens of bits in your computer simultaneously, or a total browser crash, to make Perseus fail without producing an error message of some kind. We don't crash and burn a lot, but when we do, we do it in style.</p>\\n<p><em>Note: if you're completely new to Rust, you might want to check out <a href=\\"https://doc.rust-lang.org/stable/book/\\">the Rust book</a> before starting with Perseus.</em></p>\\n<h2>You're new to web development and Rust, welcome!</h2>\\n<p>Usually, people build websites with three languages: HTML (HyperText Markup Language), CSS (Cascading Style Sheets), and JS (JavaScript). If you imagine building a bed in real life with these languages, HTML would be responsible for declaring that what you're building is a <code>&lt;bed&gt;&lt;/bed&gt;</code>, while you would use CSS to set how rounded the corners are, what color the whole thing is, what shape, what size, etc. Finally, you would use JS to make the bed, perhaps, start playing music at a certain time in the morning to wake you up.</p>\\n<p>However, these languages are all <em>interpreted</em>, meaning the browser tries to figure out what your code does as it gets it. So, if you were to, say, make a typo in some code that you put on your website, you wouldn't necessarily know until the code just doesn't run for your users, and some part of your site breaks. Although there are ways of working around these types of errors, usually with extensions to JS like <a href=\\"https://typescriptlang.org\\">TypeScript</a>, they effectively bring the power of <em>compiled</em> and <em>typed</em> languages (like <a href=\\"https://rust-lang.org\\">Rust</a>) to the web, except they're just extensions, which means they don't solve a lot the underlying problems (and they aren't any faster).</p>\\n<p>For example, let's say we have a variable <code>x</code> in JavaScript, which we set to be <code>5</code>. If we then change this to say the string <code>foo</code>, that's perfectly fine according to JS, but think about it: how many units of memory does it take to represent <code>5</code>? And how many to represent <code>foo</code>? The fact that these are different, and that this sort of thing is permissible in the language, means that JS has to do a whole lot of overhead work making everything function. Sure, it can be nice to be able to set any variable to anything, and that sort of freedom can certainly be useful for rapid prototyping (one of the great appeals of conceptually similar languages, like Python), but it doesn't make for very fast (or very safe) code.</p>\\n<p>If, instead, you were to build your site in another programming language that's <em>typed</em> (meaning, once you set <code>x = 5</code>, it can't be anything other than a number, because the language knows exactly how much memory to allocate) and <em>compiled</em> (meaning there's a stage before code execution where your code is parsed, checked for errors, and automatically optimized, being translated from human-readable code to machine-readable instructions), it could be, at a minimum, over 30% faster than one built with JS. Also, you get much more performant continuity between platforms. For example, you can happily build your site in Rust, and your server. If you were to do that with JavaScript, then both would be <em>quite slow</em>. And, when we're talking about corporate applications, even a second slower loads can do <a href=\\"https://www.cloudflare.com/learning/performance/more/website-performance-conversion-rates/\\">meaningful harm</a> to customer conversion.</p>\\n<p>Perseus is a framework for building complex websites and webapps in Rust, which consistently outperforms almost every other JS framework under the sun in benchmarks. It's based on <a href=\\"https://github.com/sycamore-rs/sycamore\\">Sycamore</a>, which provides underlying <em>reactivity</em> (which lets you do cool things like say &quot;show the value of variable <code>x</code> here and update the view whenever that variable updates&quot;), and is <a href=\\"https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html\\">faster than Svelte</a>, one of the fastest JS frameworks, in several benchmarks. On its own, Perseus will take your code, compile it, and then add an extra stage of <em>building</em> your app, in which it looks at your code, figures out the earliest pages can be prepared for users, and prepares them. So, if you have an <em>about us</em> page that's the same for every user, and that doesn't depend on users, say, being logged in, then Perseus will automatically render that page when you build your app, meaning your users will see it more quickly when they want it.</p>\\n<p>If you're completely new to web development and Rust, explaining the rest of Perseus' features will probably not be the best thing, so we'd recommend taking a look at the <a href=\\"https://developer.mozilla.org\\">MDN</a> documentation for information about web dev generally, and you should read <a href=\\"https://doc.rust-lang.org/stable/book\\">the Rust book</a> (it's not too long) to get a feel for Rust. Once you've got the basics down, you should be ready to dive straight into Perseus! And, if you need some help, don't hesitate to ask on <a href=\\"https://discord.com/invite/GNqWYWNTdp\\">our Discord</a>! Best of luck!</p>\\n<h2>Summary</h2>\\n<p>If all that was way too long, here's a quick summary of what Perseus does and why it's useful!</p>\\n<ul>\\n<li>JS is slow and a bit of a mess, <a href=\\"https://webassembly.org\\">Wasm</a> lets you run most programing languages, like Rust, in the browser, and is really fast</li>\\n<li>Doing web development without reactivity is really annoying, so <a href=\\"https://sycamore-rs.netlify.app\\">Sycamore</a> is great</li>\\n<li>Perseus lets you render your app on the server, making the client's experience <em>really</em> fast, and adds a ton of features to make that possible, convenient, and productive (even for really complicated apps)</li>\\n<li>Managing complex app state is made easy with Perseus, and it supports saving state to allow users to immediately return to exactly where they were (automatically!)</li>\\n<li>Perseus also handles errors very efficiently and safely</li>\\n<li>Perseus supports a cool thing called <em>capsules</em> that let you write some really powerful and fast code</li>\\n</ul>\\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"outdated"},"0.4.x":{"docs_rs":"0.4","git":"HEAD","state":"stable"}},"sidebar_content":"<h1>Introduction</h1>\\n<ul>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/intro\\">Introduction</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\\">Quickstart</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\\">What is Perseus?</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\\">Core Principles</a></li>\\n</ul>\\n<h1>Your First App</h1>\\n<ul>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\\">Installing Perseus</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\\">Defining your app</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\\">Generating pages</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\\">Development cycle</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\\">Error handling</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\\">Deploying your app</a></li>\\n</ul>\\n<h1>Fundamentals</h1>\\n<ul>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\\"><code>PerseusApp</code></a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\\">The reactor</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\\">Routing and navigation</a>\\n<ul>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\\">Preloading</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\\">Internationalization</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\\">Error views</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\\">Hydration</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\\">Static content</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers\\">Heads and headers</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\\">Styling</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\\">Working with JS</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\\">Servers and exporting</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\\">Debugging</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\\">Writing tests</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\\">Plugins</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\\">Improving Compilation Times</a></li>\\n</ul>\\n<h1>The State Platform</h1>\\n<ul>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\\">Understanding state</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/build\\">Build-time state</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/request\\">Request-time state</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\\">Revalidation</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\\">Incremental generation</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation\\">State amalgamation</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\\">Using state</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/global\\">Global state</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\\">Helper state</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\\">Suspended state</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\\">Freezing and thawing</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/state/manual\\">Manually implementing <code>ReactiveState</code></a></li>\\n</ul>\\n<h1>Capsules</h1>\\n<ul>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\\">Introduction</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/capsules/using\\">Using capsules</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-components\\">Capsules vs. components</a></li>\\n</ul>\\n<h1>Miscellaneous</h1>\\n<ul>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/migrating\\">Migrating from v0.3.x</a></li>\\n<li><a href=\\"https://framesurge.sh/perseus/en-US/docs/next/faq\\">Common pitfalls and FAQs</a></li>\\n</ul>\\n","status":"Next","title":"What is Perseus?"}`;
window.__PERSEUS_INITIAL_WIDGET_STATES = `{}`;
window.__PERSEUS_TRANSLATIONS = `{
    "perseus": "Perseus",
    "sycamore": "Sycamore",
    "navlinks.docs": "Docs",
    "navlinks.comparisons": "Comparisons",
    "navlinks.plugins": "Plugins",
    "index-intro.heading": "The Rust framework for the modern web",
    "index-intro.get-started-button": "Get started now",
    "index-intro.github-button": "GitHub",
    "index-state-gen.heading": "Generate state, on your terms",
    "index-state-gen.desc": "Perseus apps can generate state whenever they like and pass it to <a href=\\"https://github.com/sycamore-rs/sycamore\\" class=\\"underline\\">Sycamore</a>, one of the fastest web frameworks in the world.",
    "index-i18n.heading.start": "I18n",
    "index-i18n.heading.rest": " that just works",
    "index-i18n.heading.tooltip": "Internationalization",
    "index-i18n.desc": "Just add translations using <a href=\\"https://projectfluent.org\\" class=\\"underline\\">Fluent</a>, and your app can be set up in seconds in multiple languages, with automatic user locale detection.",
    "index-opts.heading": "You want options? We got options.",
    "index-opts.desc": "Perseus comes with a built-in plugins system and full customizability of almost every part of the system. Static exporting? Serverful deployment? Fetch data by carrier pigeon? Easy.",
    "index-speed.heading": "Fast. Crazy. Fast.",
    "index-speed.desc-line-1": "Underlying platform? <strong>Rust.</strong>",
    "index-speed.desc-line-2": "Target platform? <strong>WebAssembly.</strong>",
    "index-speed.desc-line-3": "Lighthouse scores? <strong>💯</strong>",
    "index-speed.desktop-perf-label": "Performance (Desktop)",
    "index-speed.mobile-perf-label": "Performance (Mobile)",
    "index-speed.best-practices-label": "Best Practices",
    "index-cta.heading": "Get started with Perseus today!",
    "index-cta.docs-button": "Docs",
    "index-cta.gh-button": "GitHub",
    "index-cta.api-docs-button": "API Docs",
    "index-cta.crates-io-button": "Crates.io",
    "index-cta.matrix-button": "Matrix",
    "index-cta.discord-button": "Discord",
    "index-cta.comparisons-button": "Comparisons",
    "footer.copyright": "© <a href=\\"https://github.com/arctic-hen7\\" class=\\"underline\\">arctic-hen7</a> { $years }, see license <a href=\\"https://github.com/framesurge/perseus/blob/main/LICENSE\\" class=\\"underline\\">here</a>.",
    "comparisons-title": "Comparisons to Other Frameworks",
    "comparisons-heading": "Comparisons",
    "comparisons-subtitle": "See how Perseus compares to other web development frameworks.",
    "comparisons-extra": "Is there anything we're missing here? Please <a href =\\"https://github.com/framesurge/perseus/issues/new/choose\\" class=\\"underline\\">open an issue</a> and let us know!",
    "comparisons-table-header": "Comparison",
    "comparisons-table-headings.name": "Name",
    "comparisons-table-headings.supports_ssg": "Static generation",
    "comparisons-table-headings.supports_ssr": "Server-side rendering",
    "comparisons-table-headings.supports_ssr_ssg_same_page": "SSG & SSR in same page",
    "comparisons-table-headings.supports_i18n": "Internationalization",
    "comparisons-table-headings.supports_incremental": "Incremental generation",
    "comparisons-table-headings.supports_revalidation": "Revalidation",
    "comparisons-table-headings.inbuilt_cli": "Inbuilt CLI",
    "comparisons-table-headings.inbuilt_routing": "Routing support",
    "comparisons-table-headings.supports_shell": "App shell",
    "comparisons-table-headings.supports_deployment": "Easy deployment",
    "comparisons-table-headings.supports_exporting": "Static exporting",
    "comparisons-table-headings.language": "Language",
    "comparisons-table-headings.homepage_lighthouse_desktop": "Homepage Lighthouse Score (Desktop)",
    "comparisons-table-headings.homepage_lighthouse_mobile": "Homepage Lighthouse Score (Mobile)",
    "comparisons-table-details.supports_ssg": "Whether or not the framework supports pre-rendering pages at build-time.",
    "comparisons-table-details.supports_ssr": "Whether or not the framework supports rendering pages dynamically when they're requested.",
    "comparisons-table-details.supports_ssr_ssg_same_page": "Whether or not the framework supports SSG and SSR (see above) in the very same page.",
    "comparisons-table-details.supports_i18n": "Whether or not the framework supports building a multilingual app. Some frameworks support this through plugins.",
    "comparisons-table-details.supports_incremental": "Whether or not the framework supports rendering pages on-demand and then caching them for future use.",
    "comparisons-table-details.supports_revalidation": "Whether or not the framework supports rebuilding pages that were built at build-time at request-time. Some frameworks can do this by time, or by custom logic. Perseus supports both.",
    "comparisons-table-details.inbuilt_cli": "Whether or not the framework has a command-line interface for convenient usage. Some frameworks use third-party CLIs.",
    "comparisons-table-details.inbuilt_routing": "Whether or not the framework supports inbuilt routing. Most frameworks have their own way of doing this if they do support it.",
    "comparisons-table-details.supports_shell": "Whether or not this framework has an app shell, which makes switching pages much faster and cleaner.",
    "comparisons-table-details.supports_deployment": "Whether or not this framework supports easy deployment. Perseus can deploy in one command.",
    "comparisons-table-details.supports_exporting": "Whether or not this framework can operate without a server, as a series of purely static files.",
    "comparisons-table-details.language": "The programming language this framework is built in. (Hint: Rust is the fastest!)",
    "comparisons-table-details.homepage_lighthouse_desktop": "The Lighthouse score out of 100 for desktop (higher is better). These are collected from Google's PageSpeed Insights tool. These are for the framework's website, and may not reflect the performance of all sites made with the framework.",
    "comparisons-table-details.homepage_lighthouse_mobile": "The Lighthouse score out of 100 for mobile (higher is better). These are collected from Google's PageSpeed Insights tool. These are for the framework's website, and may not reflect the performance of all sites made with the framework.",
    "comparisons-sycamore-heading": "Perseus vs Sycamore",
    "comparisons-sycamore-text": "Perseus is a framework that uses Sycamore to write views (the things users see), so there's not much point in comparing the two as competitors. However, Sycamore can be used without Perseus, which works perfectly well, though you'll miss out on features like inbuilt internationalization, static generation (though you could build this yourself), and incremental generation. If you want to build just a bit of your site with Rust, Sycamore is the perfect tool, Perseus is a full framework designed for building entire websites.",
    "comparisons-unknown-heading": "Perseus vs { $name }",
    "docs-title-base": "Perseus Docs",
    "docs-status.outdated": "This version of the documentation is outdated, and features documented here may work differently now. You can see the latest stable version of the docs <a href=\\"en-US/docs/{ $stable }/intro\\" class=\\"underline\\">here</a>.",
    "docs-status.beta": "This version of the documentation is for a version that has only been released in beta, and is not yet stable. Features documented here may not be present in the latest stable version, and they're subject to rapid and drastic change. You can see the latest stable version of the docs <a href=\\"en-US/docs/{ $stable }/intro\\" class=\\"underline\\">here</a>.",
    "docs-status.next": "This version of the documentation is for a version that has not yet been released, and features documented here may not be present in the latest release. You can see the latest stable version of the docs <a href=\\"en-US/docs/{ $stable }/intro\\" class=\\"underline\\">here</a>.",
    "docs-version-switcher.next": "Next (unreleased)",
    "docs-version-switcher.beta": "v{ $version } (beta)",
    "docs-version-switcher.stable": "v{ $version } (stable)",
    "docs-version-switcher.outdated": "v{ $version } (outdated)",
    "plugins-title": "Plugins",
    "plugins-title-full": "Perseus Plugins",
    "plugin-card-author": "By { $author }",
    "plugin-details.repo_link": "Repository:",
    "plugin-details.crates_link": "Crate page:",
    "plugin-details.docs_link": "Docs:",
    "plugin-details.site_link": "Site:",
    "plugin-details.metadata_heading": "Metadata",
    "plugin-details.no_link_text": "N/A",
    "plugin-search.placeholder": "Search",
    "plugin-search.no_results": "No results found.",
    "plugins-desc": "These are all the public plugins for Perseus! If you've made a plugin, and you'd like it to be listed here, please open an issue on our repository!",
    "search": "Search the docs",
    "index-example-switcher.excerpts": "Excerpts",
    "index-example-switcher.full": "Full"
}
`;</script><meta itemprop=__perseus_head_end><script>//</script><body class="bg-white dark:bg-neutral-900"><div id=root><header data-hk=8.0 class="shadow-md sm:p-2 w-full mb-20 bg-neutral-500/30 backdrop-blur-lg text-black dark:text-white"><div data-hk=8.1 class="flex justify-between items-center"><a data-hk=8.2 class="justify-self-start self-center m-3 ml-5 text-md sm:text-2xl text-bold title-font"href=en-US/>Perseus</a><div data-hk=8.3 class="md:hidden m-3 mr-5 tham tham-e-spin tham-w-6"><div data-hk=8.4 class=tham-box><div data-hk=8.5 class="tham-inner bg-black dark:bg-white"></div></div></div><nav data-hk=8.6 class="hidden md:flex"><ul data-hk=8.7 class="mr-5 flex"><li data-hk=9.0 class="m-3 p-1 title-font"><a data-hk=9.1 href=en-US/docs class=px-2>Docs</a><li data-hk=9.2 class="m-3 p-1 title-font"><a data-hk=9.3 href=en-US/comparisons class=px-2>Comparisons</a><li data-hk=9.4 class="m-3 p-1 title-font"><a data-hk=9.5 href=en-US/plugins class=px-2>Plugins</a></ul></nav></div><nav data-hk=8.8 id=mobile_nav_menu class="md:hidden w-full text-center justify-center hidden"><ul data-hk=8.9 class=mr-5><li data-hk=10.0 class="m-3 p-1 title-font"><a data-hk=10.1 href=en-US/docs class=px-2>Docs</a><li data-hk=10.2 class="m-3 p-1 title-font"><a data-hk=10.3 href=en-US/comparisons class=px-2>Comparisons</a><li data-hk=10.4 class="m-3 p-1 title-font"><a data-hk=10.5 href=en-US/plugins class=px-2>Plugins</a></ul><hr data-hk=2.0><div data-hk=2.1 class="text-left p-3 overflow-y-scroll h-[60vh]"><div data-hk=2.2 class="flex w-full justify-center text-center"><div data-hk=2.3 class="max-w-3xl flex flex-col"><select data-hk=4.4 class="p-2 rounded-md text-white bg-indigo-500"><option data-hk=4.5 value=next selected>Next (unreleased)<option data-hk=4.6 value=0.4.x>v0.4.x (stable)<option data-hk=4.0 value=0.3.4>v0.3.4 (outdated)<option data-hk=4.1 value=0.3.0-0.3.3>v0.3.0-0.3.3 (outdated)<option data-hk=4.2 value=0.2.x>v0.2.x (outdated)<option data-hk=4.3 value=0.1.x>v0.1.x (outdated)</select></div></div><div data-hk=2.4 class=docs-links-markdown><h1>Introduction</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/intro>Introduction</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/quickstart>Quickstart</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus>What is Perseus?</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/core-principles>Core Principles</a></ul><h1>Your First App</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/installation>Installing Perseus</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/defining>Defining your app</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages>Generating pages</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle>Development cycle</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling>Error handling</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying>Deploying your app</a></ul><h1>Fundamentals</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app><code>PerseusApp</code></a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor>The reactor</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing>Routing and navigation</a> <ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading>Preloading</a></ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n>Internationalization</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views>Error views</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration>Hydration</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content>Static content</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers>Heads and headers</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling>Styling</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop>Working with JS</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting>Servers and exporting</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging>Debugging</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing>Writing tests</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins>Plugins</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times>Improving Compilation Times</a></ul><h1>The State Platform</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/intro>Understanding state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/build>Build-time state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/request>Request-time state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/revalidation>Revalidation</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/incremental>Incremental generation</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation>State amalgamation</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/browser>Using state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/global>Global state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/helper>Helper state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/suspense>Suspended state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing>Freezing and thawing</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/manual>Manually implementing <code>ReactiveState</code></a></ul><h1>Capsules</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/capsules/intro>Introduction</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/capsules/using>Using capsules</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-components>Capsules vs. components</a></ul><h1>Miscellaneous</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/migrating>Migrating from v0.3.x</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/faq>Common pitfalls and FAQs</a></ul></div></div></nav></header><main data-hk=2.20 id=scroll-container><div data-hk=2.5 class="flex w-full"><div data-hk=2.6 class="h-screen pt-14 xs:pt-16 sm:pt-20 lg:pt-25 hidden md:block max-w-xs w-full border-r overflow-y-auto"><div data-hk=2.7 class=mr-5><div data-hk=2.8 class="text-left text-black dark:text-white p-3"><aside data-hk=2.9><div data-hk=2.10 class="flex flex-col"><select data-hk=6.4 class="p-2 rounded-md text-white bg-indigo-500"><option data-hk=6.5 value=next selected>Next (unreleased)<option data-hk=6.6 value=0.4.x>v0.4.x (stable)<option data-hk=6.0 value=0.3.4>v0.3.4 (outdated)<option data-hk=6.1 value=0.3.0-0.3.3>v0.3.0-0.3.3 (outdated)<option data-hk=6.2 value=0.2.x>v0.2.x (outdated)<option data-hk=6.3 value=0.1.x>v0.1.x (outdated)</select></div><div data-hk=2.11 class=docs-links-markdown><h1>Introduction</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/intro>Introduction</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/quickstart>Quickstart</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus>What is Perseus?</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/core-principles>Core Principles</a></ul><h1>Your First App</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/installation>Installing Perseus</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/defining>Defining your app</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages>Generating pages</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle>Development cycle</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling>Error handling</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying>Deploying your app</a></ul><h1>Fundamentals</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app><code>PerseusApp</code></a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor>The reactor</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing>Routing and navigation</a> <ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading>Preloading</a></ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n>Internationalization</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views>Error views</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration>Hydration</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content>Static content</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers>Heads and headers</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling>Styling</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop>Working with JS</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting>Servers and exporting</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging>Debugging</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing>Writing tests</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins>Plugins</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times>Improving Compilation Times</a></ul><h1>The State Platform</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/intro>Understanding state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/build>Build-time state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/request>Request-time state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/revalidation>Revalidation</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/incremental>Incremental generation</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation>State amalgamation</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/browser>Using state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/global>Global state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/helper>Helper state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/suspense>Suspended state</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing>Freezing and thawing</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/state/manual>Manually implementing <code>ReactiveState</code></a></ul><h1>Capsules</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/capsules/intro>Introduction</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/capsules/using>Using capsules</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-components>Capsules vs. components</a></ul><h1>Miscellaneous</h1><ul><li><a href=https://framesurge.sh/perseus/en-US/docs/next/migrating>Migrating from v0.3.x</a><li><a href=https://framesurge.sh/perseus/en-US/docs/next/faq>Common pitfalls and FAQs</a></ul></div></aside></div></div></div><div data-hk=2.12 class="h-screen pt-14 xs:pt-16 sm:pt-20 lg:pt-25 grid grid-rows-[1fr_min-content] w-full overflow-y-auto"><div data-hk=2.13 class="px-3 w-full sm:mr-auto sm:ml-auto sm:max-w-prose lg:max-w-3xl xl:max-w-4xl 2xl:max-w-5xl min-w-0"><div data-hk=2.14 class="ring-4 ring-orange-400 p-4 rounded-lg mt-1"><div data-hk=2.15 class="flex flex-col 2xs:flex-row dark:text-white"><span data-hk=2.16 class="self-center mr-2"style="fill: #fb923c;"><svg xmlns=http://www.w3.org/2000/svg height=auto viewbox="0 0 24 24"width=2.25rem fill=\#000000><path d="M12 7c.55 0 1 .45 1 1v4c0 .55-.45 1-1 1s-1-.45-1-1V8c0-.55.45-1 1-1zm-.01-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm1-3h-2v-2h2v2z"/></svg></span><p data-hk=2.17>This version of the documentation is for a version that has not yet been released, and features documented here may not be present in the latest release. You can see the latest stable version of the docs <a href=en-US/docs/0.4.x/intro class=underline>here</a>.</div></div><main data-hk=2.18 class="text-black dark:text-white"><div data-hk=1.0 class="markdown min-w-0 pb-10"><h1>What is Perseus?</h1><p>Perseus is a <strong>web development framework</strong> for the <strong>Rust</strong> programming language that focuses on the <strong>state</strong> of your app. Since there are three main ways you might approach Perseus, we'll break down each one individually here.<h2>You're familiar with Rust</h2><p>We can obviously agree that Rust is much better than JavaScript: it's way faster, strongly-typed, has a great compiler, and a fantastic package management system. In the browser, it runs <em>amazingly</em>. This is because of <a href=https://webassembly.org>WebAssembly</a> (abbreviated <em>Wasm</em>), which is basically an assembly language for programs like Chrome, Firefox, etc. With it, you can compile your Rust code to run in the browser, and even access browser APIs, allowing you to display content to the user. In the past, Rust has been used with Wasm to perform things like heavy cryptography, but Perseus lets you exile JS completely, and run your whole site with Rust only.<p>Now, you might have come across other web development libraries and frameworks for Rust before, but there's a big difference between those two terms, so let's sort that out first. A <em>library</em> is a piece of code that you use to help you build your site. A <em>framework</em> is a mammoth of code that uses your code to build your site. Think of it like the difference between <code>futures::executor::block_on</code> and <code>#[tokio::main]</code>: one is being used by you to handle a bit of <code>async</code>, and the other is using your code to handle <em>all</em> the <code>async</code>. In the same way, a library is a great choice for when you want to build a small site, or when you want to replace just part of a site with Rust. For these kinds of things, we absolutely recommend <a href=https://github.com/sycamore-rs/sycamore>Sycamore</a>, on which Perseus is based.<p>However, sometimes you'll need to break out the big guns. Sometimes, you'll need to render content in advance so that your users see it straight away, rather than a blank page while your Wasm boots up. Sometimes, you'll want to have a <em>stateful</em> app. This doesn't just mean you've got buttons and forms, etc., but that you're building your app in a special kind of pattern, which Perseus is built around. Let's say you have a simple static blog: you might have a <code>/post</code> URL, under which all your posts can be found. Fundamentally, all these posts have the same structure, just with different titles, dates, tags, and contents, so you might choose to create some kind of <em>template</em> for them, and then maybe build a Markdown parser or the like to push all that into your app to create <em>pages</em>. Essentially, <strong>template + state = page</strong>. In Perseus, this is all handled for you, and you just create templates, like <code>/post</code>, along with ways to render their state.<p>For example, for a blog, you might create a new post template with <code>Template::build("post")</code>, and then create a function that takes in some state and plugs it into a Sycamore <code>view! { .. }</code> to render some content. You might take in a <code>struct</code> containing contents, titles, tags, etc. If you then specify a function that can list the pages that this template should create (e.g. by getting all the Markdown files in a certain directory), and then another one that takes each path and generates state for it, Perseus will string it all together and give a lightning-fast app.<p>Beyond this, Perseus has all sorts of extra features, like inbuilt error handling systems that allow you to gracefully display error messages if state generation fails, or if your app panics, or something else like that. All you do is match an <code>enum ClientError</code>, and Perseus shows your errors to the client. Beyond that, if you want to build an app in multiple languages, Perseus will let you do it straight away: just replace the text in your code with identifiers inside the <code>t!()</code> macro, and define a map of translation IDs to text for each language you want to support. Variable interpolation is supported out of the box, and you can unleash the full power of <a href=https://projectfluent.org>Fluent</a> for handling pluralization rules, genders, etc.<p>Going even further, Perseus' state generation platform is built for even the most advanced use-cases: let's say you have not a blog, but an ecommerce site selling a thousand products. Well, a thousand would actually build very quickly, so perhaps a million. Still probably looking at less than a second, but we'll go with it. Maybe you don't want to build all that at build time. Simple! Just add <code>.incremental_generation()</code> to your template definition and then...you're done. If a user goes to a product page that doesn't exist yet, it will be passed to your state generation functions, and, if it's a page that exists, those functions can produce the page, and Perseus will serve it. For any future users, that page will be cached and returned immediately. It's like building your whole app over time, on-demand. And, if you have an index of all your products, you could automatically <em>revalidate</em> that every, say, 24 hours, to make sure users have a fairly up-to-date listing. Or you could logic-based revalidation that checks each time whether or not there are actually any new products, before rebuilding. You could even combine the two: only check every few hours whether or not there are new products, and, if there are, rebuild that page.<p>To be clear, and this is important if you aren't familiar with web development, Perseus is not a library, it's a framework. It's a giant engine into which you plug your code that will connect everything together and optimize it, producing a super-fast site that outperforms every JS framework under the sun. It might well seem like you don't need a lot of these features, and, if you don't, you can just run <code>perseus export</code> to get a series of static HTML files that you can serve to users however you like, with a simple Wasm bundle making sure whatever interactivity you have works as smoothly as possible (and it will still be unreasonably fast). If you're used to systems programming, the whole idea of a framework might seem a bit absurd, but it's very often required in web development, simply because the best experiences come from complex features, like rendering your site to HTML in advance, or caching transactions, or delayable capsules that can be infinitely nested to create lazy-loaded pages, etc. Some of these are easy to implement, others are not. The point of Perseus is to handle this all for you so you can get on with what you want to write: your app. Even better, Perseus is built on <a href=https://github.com/sycamore-rs/sycamore>Sycamore</a>, which handles reactivity primitives, meaning there is a separation of concerns, unlike with other current Rust frameworks: one team is in charge of the reactivity, and another in charge of the framework, meaning more features are developed more quickly, and bugs are fixed more rapidly, while both systems remain fantastically maintained.<p>If Perseus doesn't sound like your cup of tea, there are several other Rust frameworks you might like to check out: <a href=https://github.com/sycamore-rs/sycamore>Sycamore</a> is the library on which Perseus is based, if you want to keep the same sort of style; <a href=https://yew.rs>Yew</a> is a very popular library; and <a href=https://seed-rs.org>Seed</a> is another. There's also <a href=https://github.com/ivanceras/sauron>Sauron</a>, <a href=https://github.com/MoonZoon/MoonZoon>MoonZoon</a>, and <a href=https://github.com/leptos-rs/leptos>Leptos</a>, just to name a few. If you'd like to see some more in-depth comparisons between these projects, check out <a href=comparisons>the comparisons page</a>.<h2>You're familiar with JavaScript, and you've know what NextJS, ReactJS, etc. mean</h2><p>Alright, you're pretty familiar with what web development is, and why we tend to need frameworks to make things simple and to remove the need to write hundreds of lines of boilerplate code for features we use in every app. But you've probably got plenty of questions about Perseus.<h3>Why Rust?</h3><p>Put simply, JS is <a href=https://medium.com/netscape/javascript-is-kinda-shit-im-sorry-2e973e36fec4>a bit of a mess</a>. It's dynamically-typed, and executed at runtime, meaning you can't really catch bugs while you're coding. Sure, an IDE helps with this by showing you squiggly red lines, but it still won't stop you from forgetting about passing a certain argument to a function. TypeScript helps with this by introducing stricter typing rules, but it's really an addition on top of already existing JavaScript, and, let's be honest, how many times have you had to search up solutions for getting your <code>tsconfig</code> to work?<p><a href=https://rust-lang.org>Rust</a>, on the other hand, is generally thought of as a systems programming language, meaning it's much lower-level and closer to the hardware, letting you do things like memory management more manually. It's certainly got a much steeper learning curve, but, let's walk through a quick example. Imagine you have a variable <code>data</code> that contains a very large amount of information. Obviously, copying this is going to slow your program down, so we want to avoid that if possible. In JS, you could do something like this:<pre><code class=language-javascript>const data = "...";
let valid = isDataValid(data);
let useful = isDataUseful(data);
</code></pre><p>You might not realize it, but this code could copy the whole of <code>data</code> under certain conditions, because, when you think about it, both <code>isDataValid()</code> and <code>isDataUseful()</code> need it. In fact, depending on your code's structure, JS might even implicitly copy this whole variable <em>twice</em>! This is an oversimplification, and there's a lot more going on here, but, in Rust, you have total control over this:<pre><code class=language-rust>let data = get_data();
let valid = is_data_valid(&data);
let useful = is_data_useful(&data);
</code></pre><p>Here, we're passing <em>references</em> to <code>data</code> to those functions, which are like telling them where <code>data</code> can be found in memory, rather than giving them it's actual value. Again, we're oversimplifying, but the point is that Rust allows you much lower-level control over your data, and it's a compiled language, meaning you have to build your code into an executable, rather than just running it. In this stage, the compiler goes over your code with a fine-toothed comb, finding whole classes of bugs and making them impossible at runtime. And, to make things even better, <em>undefined behavior</em>, a special type of bug in C/C++/etc. (which often leads to <code>Segmentation fault</code> messages, which you might have seen before), is literally impossible in Rust, because the whole language is built on a clear boundary between <em>safe</em> code, and <em>unsafe</em> code. The latter might cause UB, and should explicitly clarify what has to be upheld for it to all work properly. Then, if code can be certain that it's upholding the necessary invariants, it can call itself safe. Basically, where the compiler can't prove that your code won't crash and burn, you explicitly have to, and there's no getting around it.<p>To illustrate just how powerful this model of programming is, let's take a bit of a meta-example. When we were building Perseus v0.4.0, we had to rewrite the entire Perseus core, over 12,000 lines of code. After innumerable cycles of changing some code and seeing errors pop up in the terminal, when we got all the errors fixed and the code actually compiled, the first time we ran <code>perseus build</code>, <em>it worked</em>. No logic bugs, no syntax errors, it just worked. <em>That</em> is the kind of power you get from working with Rust. (and absolutely ludicrous speeds.)<p>Usefully, the Rust compiler supports compiling for different <em>targets</em>, which are basically formats of machine code. Your Rust code can be turned into code that will run on Linux, macOS, Windows, etc. Or, it could run in the browser, through a revolutionary new technology called <a href=https://webassembly.org>WebAssembly</a>, abbreviated as <em>Wasm</em>. Technically, any language, like C or C++, could compile into this format, but Rust has the added guarantees of <em>safety</em>.<p>Oh, and did we mention that Rust is <a href=https://medium.com/@xpf6677/40x-faster-we-rewrote-our-project-with-rust-120b006c6abe>insanely fast</a>?<p>When you combine that with Wasm, a Rust site is usually >30% faster than the equivalent site built in JavaScript, in terms of runtime performance. And, when we say >30%, we mean >90% on anything modern that's not running Safari (Apple being a bastion of implementing web standards, as usual).<p>With all this, Rust is the perfect language to implement a next-generation web framework in, and that's exactly what Perseus is.<h3>Okay, but what <em>is</em> it?</h3><p>As NextJS is to ReactJS, Perseus is to <a href=https://github.com/sycamore-rs/sycamore>Sycamore</a>. Sycamore is a low-level reactive library for building websites in Rust that uses <em>no virtual DOM</em>, making it <a href=https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html>faster than Svelte</a> in some cases (with improvements on the horizon to get <em>even faster</em>), and Perseus builds on these foundations to create a framework designed to make your life easier by minimizing boilerplate.<p>Assuming you're familiar with a few terms from the usual JS jargon about frameworks, let's run through Perseus' features. It supports static site generation (building your app to HTML before it's even running), server-side rendering (building pages at request-time based on user details, like cookies), client-side rendering (fetching data in the browser to render components), using SSG and SSR <em>on the same page</em> (which, to our knowledge, no other framework in the world supports), revalidation (allowing you to rebuild a page that was built originally at build-time, based on either timing or custom logic), incremental generation (rendering a page at request-time the first time it's requested, and then caching it for future use so it can be returned instantly next time), and <a href=https://framesurge.sh/perseus/en-US/docs/next/capsules/intro><em>capsules</em></a>.<p>This is all based around <em>state</em>, because that's the focus of Perseus. Unashamedly, Perseus focuses on supporting highly complex apps with many moving parts and interconnected components. Of course, if you want to build a static blog, that's a piece of cake.<p>Fundamentally, Perseus boils down to a state framework, and, really, the whole idea of actually displaying content to a user is secondary. As far as Perseus is concerned, your state is generated in almost any way conceivable, it gets to the user, it's made <em>reactive</em> of its own accord (meaning, if you're coming from React, that any state you generate on the server comes to you already in a <code>useState()</code> hook), and then you can work with it however you like to display it to users (that's <a href=https://github.com/sycamore-rs/sycamore>Sycamore</a>'s job). If your site isn't interactive (like a static blog), you can use unreactive state instead, no problem.<p>Based on this, Perseus' rendering model comes down to <em>templates</em>, which are like stencils for creating pages. For example, you might have a blog post template at the <code>post</code> URL, which would have the basic structure that all blog posts share. When you plug in the data of an individual blog post called <code>foo</code>, you get out that template, filled in with that state, to produce <code>post/foo</code>, a page.<p>In essence, <strong>template + state = page</strong>, that's the fundamental equation of Perseus.<p>But, we went further than this. If you're familiar with <a href=https://astro.build>Astro</a>, then you'll have heard of the <em>islands architecture</em>, where you split your app into components that can individually render, hydrate, etc. Now, things are a bit different over here in Wasm-world, because things are so fast here that we don't really have to care about delaying hydration, or things like that, because it all happens just about instantly. Instead, our main concern is minimizing the amount of <em>stuff</em> (i.e. HTML and Wasm) that needs to be sent to the user's browser, because that's the real bottleneck for us. So, if you split out a complex ecommerce page into, say, a <em>widget</em> (Perseus' term for islands) for each product on your home page, then your home page can load as a simple skeleton waiting for some content. It's kind of like a template waiting for state, but the pieces that need to be filled in are actual mini-pages themselves. In fact, unlike any other framework ever created, Perseus has the unique concept that <strong>capsule + state = widget</strong>. That's right, as a template creates pages, a capsule creates widgets, meaning you can have a <code>product</code> capsule that incrementally generates product widgets as they're requested. You can use every single rendering strategy that works for pages on widgets, and you can control exactly when they're rendered too. If you want, say, the first row of products on your website's landing page to be instantly rendered, and then the rest to be lazy-loaded in parallel, you can do that by chaining <code>.widget()</code> to <code>.delayed_widget()</code>. It's that simple. Oh, and <em>everything</em> is cached by Perseus at the application-level, taking single-page routing into the world of caching and ensuring that users can literally <em>instantly</em> navigate back to any pages they've visited in the past.<p>Naturally, Perseus also comes with the usual stew of extra framework features, like internationalization out of the box that just works (translator APIs etc. are all available for you, and you can pick a really powerful one using <a href=https://projectfluent.org>Fluent</a> or a really tiny one using JSON, with more to come), and one-command deployment to a <code>pkg/</code> folder that you put literally anywhere that runs executables. And if you want a static site, you just run <code>perseus export</code>, and you're set.<p>As for the Lighthouse scores, Perseus achieves 100 on desktop without even trying, and consistently above 90 on mobile. The dropoff in mobile performance is mostly because of the way mobile browsers still have to go in optimizing Wasm, but this will improve with time, and any user on a modern smartphone will see a snappy and responsive site practically instantly. That whole idea of render-then-hydrate is baked into Perseus: your users see content straight away, and it becomes reactive a moment later.<p>Unfortunately, the idea of <em>resumability</em>, as pioneered by <a href=https://qwik.builder.io>Qwik</a>, isn't really possible with Wasm yet, because you actually can't split a Wasm bundle into smaller pieces, you just send the whole thing to the user. While that does mean that Perseus apps are <em>insanely</em> fast when going between pages, it can mean slightly slower load times when a user first comes to your site. That said, it's still 100 on Lighthouse, so it can't be <em>that</em> bad. Even so, we're sure you've had that bad experience of loading a site and trying to press buttons that don't work, and knowing (as a developer) that it's because the site hasn't hydrated yet. Now, with Perseus, your users really won't be waiting too long for those buttons to be working, but you can enable a feature flag that holds user interactions in stasis until your app is hydrated, before automatically re-sending them, leading to a much better overall user experience. And, if you don't like it, you can just turn it off.<p>The other really cool thing about Perseus is <em>error handling</em>. A lot of JS frameworks have this concept of <em>error boundaries</em>, but still more leave all the error management to you. If JS blows up (as it frequently does), you're left to clean up on your own. In Rust, errors have to be propagated explicitly with a type called <code>Result</code>, which can either be <code>Ok</code> or <code>Err</code>. Unless a function <code>panic!</code>s, it can't rip the floor out from under you and cause everything to fail. That means Perseus can handle nearly all errors gracefully: for example, if a single widget can't render its contents properly, it will automatically render an error instead. If Perseus can't start up your app, but it knows the user can already see some content, it will show a popup error message instead of replacing the perfectly good static content. And, if your whole app panics, crashing and burning to the ground, Perseus gives you the opportunity to run arbitrary code (like crash analytics) as well as display a nice error message to the user. And, because Rust is strongly-typed, if you forget to explicitly handle (or not handle) a particular type of error, your app just won't compile, and you'll get a lovely error message from the compiler. Basically, it would take an alignment of cosmic rays flipping dozens of bits in your computer simultaneously, or a total browser crash, to make Perseus fail without producing an error message of some kind. We don't crash and burn a lot, but when we do, we do it in style.<p><em>Note: if you're completely new to Rust, you might want to check out <a href=https://doc.rust-lang.org/stable/book/>the Rust book</a> before starting with Perseus.</em><h2>You're new to web development and Rust, welcome!</h2><p>Usually, people build websites with three languages: HTML (HyperText Markup Language), CSS (Cascading Style Sheets), and JS (JavaScript). If you imagine building a bed in real life with these languages, HTML would be responsible for declaring that what you're building is a <code>&LTbed>&LT/bed></code>, while you would use CSS to set how rounded the corners are, what color the whole thing is, what shape, what size, etc. Finally, you would use JS to make the bed, perhaps, start playing music at a certain time in the morning to wake you up.<p>However, these languages are all <em>interpreted</em>, meaning the browser tries to figure out what your code does as it gets it. So, if you were to, say, make a typo in some code that you put on your website, you wouldn't necessarily know until the code just doesn't run for your users, and some part of your site breaks. Although there are ways of working around these types of errors, usually with extensions to JS like <a href=https://typescriptlang.org>TypeScript</a>, they effectively bring the power of <em>compiled</em> and <em>typed</em> languages (like <a href=https://rust-lang.org>Rust</a>) to the web, except they're just extensions, which means they don't solve a lot the underlying problems (and they aren't any faster).<p>For example, let's say we have a variable <code>x</code> in JavaScript, which we set to be <code>5</code>. If we then change this to say the string <code>foo</code>, that's perfectly fine according to JS, but think about it: how many units of memory does it take to represent <code>5</code>? And how many to represent <code>foo</code>? The fact that these are different, and that this sort of thing is permissible in the language, means that JS has to do a whole lot of overhead work making everything function. Sure, it can be nice to be able to set any variable to anything, and that sort of freedom can certainly be useful for rapid prototyping (one of the great appeals of conceptually similar languages, like Python), but it doesn't make for very fast (or very safe) code.<p>If, instead, you were to build your site in another programming language that's <em>typed</em> (meaning, once you set <code>x = 5</code>, it can't be anything other than a number, because the language knows exactly how much memory to allocate) and <em>compiled</em> (meaning there's a stage before code execution where your code is parsed, checked for errors, and automatically optimized, being translated from human-readable code to machine-readable instructions), it could be, at a minimum, over 30% faster than one built with JS. Also, you get much more performant continuity between platforms. For example, you can happily build your site in Rust, and your server. If you were to do that with JavaScript, then both would be <em>quite slow</em>. And, when we're talking about corporate applications, even a second slower loads can do <a href=https://www.cloudflare.com/learning/performance/more/website-performance-conversion-rates/>meaningful harm</a> to customer conversion.<p>Perseus is a framework for building complex websites and webapps in Rust, which consistently outperforms almost every other JS framework under the sun in benchmarks. It's based on <a href=https://github.com/sycamore-rs/sycamore>Sycamore</a>, which provides underlying <em>reactivity</em> (which lets you do cool things like say "show the value of variable <code>x</code> here and update the view whenever that variable updates"), and is <a href=https://rawgit.com/krausest/js-framework-benchmark/master/webdriver-ts-results/table.html>faster than Svelte</a>, one of the fastest JS frameworks, in several benchmarks. On its own, Perseus will take your code, compile it, and then add an extra stage of <em>building</em> your app, in which it looks at your code, figures out the earliest pages can be prepared for users, and prepares them. So, if you have an <em>about us</em> page that's the same for every user, and that doesn't depend on users, say, being logged in, then Perseus will automatically render that page when you build your app, meaning your users will see it more quickly when they want it.<p>If you're completely new to web development and Rust, explaining the rest of Perseus' features will probably not be the best thing, so we'd recommend taking a look at the <a href=https://developer.mozilla.org>MDN</a> documentation for information about web dev generally, and you should read <a href=https://doc.rust-lang.org/stable/book>the Rust book</a> (it's not too long) to get a feel for Rust. Once you've got the basics down, you should be ready to dive straight into Perseus! And, if you need some help, don't hesitate to ask on <a href=https://discord.com/invite/GNqWYWNTdp>our Discord</a>! Best of luck!<h2>Summary</h2><p>If all that was way too long, here's a quick summary of what Perseus does and why it's useful!<ul><li>JS is slow and a bit of a mess, <a href=https://webassembly.org>Wasm</a> lets you run most programing languages, like Rust, in the browser, and is really fast<li>Doing web development without reactivity is really annoying, so <a href=https://sycamore-rs.netlify.app>Sycamore</a> is great<li>Perseus lets you render your app on the server, making the client's experience <em>really</em> fast, and adds a ton of features to make that possible, convenient, and productive (even for really complicated apps)<li>Managing complex app state is made easy with Perseus, and it supports saving state to allow users to immediately return to exactly where they were (automatically!)<li>Perseus also handles errors very efficiently and safely<li>Perseus supports a cool thing called <em>capsules</em> that let you write some really powerful and fast code</ul></div></main></div><div data-hk=2.19 class=row-start-2><footer data-hk=7.0 class="w-full flex justify-center py-5 bg-black text-white"><p data-hk=7.1 class="mx-5 text-center"><span data-hk=7.2>© <a href=https://github.com/arctic-hen7 class=underline>arctic-hen7</a> 2021-2023, see license <a href=https://github.com/framesurge/perseus/blob/main/LICENSE class=underline>here</a>.</span></footer></div></div></div></main><script data-hk=0.0 src=.perseus/static/prism.js defer></script><script data-hk=0.1>window.Prism.highlightAll();</script></div><div id=__perseus_popup_error></div>