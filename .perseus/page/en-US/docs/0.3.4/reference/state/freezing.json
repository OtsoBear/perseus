{"state":{"content":"<h1>State Freezing</h1>\n<p>If you use the reactive and global state systems to their full potential, your entire app can be represented as its state. So what if you could make all that state unreactive again, serialize it to a string, and keep it for later? Well, you'd be able to let your users pick up at the <em>exact</em> same place they were when they come back later. Imagine you're in the middle of filling out some forms and then your computer crashes. You boot back up and go to the website you were on. If it's built with Perseus and state freezing occurred just before the crash, you're right back to where you were. Same page, same inputs, same everything.</p>\n<p>Specifically, Perseus achieves this by serializing the global state and the page state store, along with the route that the user's currently on. You can invoke this easily by running <code>.freeze()</code> on the render context, which you can access with <code>perseus::get_render_ctx!()</code>. Best of all, if state hasn't been used yet (e.g. a page hasn't been visited), it won't be cached, because it doesn't need to be. That also applies to global state, meaning the size of your frozen output is minimized (note that this isn't property-level granular yet, but that <em>might</em> be investigated in future).</p>\n<h2>Example</h2>\n<p>You can easily imperatively instruct your app to freeze itself like so (see <a href=\"https://github.com/framesurge/perseus/tree/main/examples/core/freezing_and_thawing/src/templates/index.rs\">here</a>):</p>\n<pre><code class=\"language-rust\">use perseus::state::Freeze;\nuse perseus::{Html, RenderFnResultWithCause, Template};\nuse sycamore::prelude::*;\n\nuse crate::global_state::AppStateRx;\n\n#[perseus::make_rx(IndexPropsRx)]\npub struct IndexProps {\n    username: String,\n}\n\n#[perseus::template_rx]\npub fn index_page(state: IndexPropsRx, global_state: AppStateRx) -&gt; View&lt;G&gt; {\n    let username = state.username;\n    let username_2 = username.clone(); // This is necessary until Sycamore's new reactive primitives are released\n    let test = global_state.test;\n    let test_2 = test.clone();\n\n    // This is not part of our data model, we do NOT want the frozen app synchronized as part of our page's state, it should be separate\n    let frozen_app = Signal::new(String::new());\n    let frozen_app_2 = frozen_app.clone();\n    let frozen_app_3 = frozen_app.clone();\n    let render_ctx = perseus::get_render_ctx!();\n\n    view! {\n        // For demonstration, we'll let the user modify the page's state and the global state arbitrarily\n        p(id = &quot;page_state&quot;) { (format!(&quot;Greetings, {}!&quot;, username.get())) }\n        input(id = &quot;set_page_state&quot;, bind:value = username_2, placeholder = &quot;Username&quot;)\n        p(id = &quot;global_state&quot;) { (test.get()) }\n        input(id = &quot;set_global_state&quot;, bind:value = test_2, placeholder = &quot;Global state&quot;)\n\n        // When the user visits this and then comes back, they'll still be able to see their username (the previous state will be retrieved from the global state automatically)\n        a(href = &quot;about&quot;, id = &quot;about-link&quot;) { &quot;About&quot; }\n        br()\n\n        button(id = &quot;freeze_button&quot;, on:click = cloned!(frozen_app, render_ctx =&gt; move |_| {\n            frozen_app.set(render_ctx.freeze());\n        })) { &quot;Freeze!&quot; }\n        p(id = &quot;frozen_app&quot;) { (frozen_app.get()) }\n\n        input(id = &quot;thaw_input&quot;, bind:value = frozen_app_2, placeholder = &quot;Frozen state&quot;)\n        button(id = &quot;thaw_button&quot;, on:click = cloned!(frozen_app_3, render_ctx =&gt; move |_| {\n            render_ctx.thaw(&amp;frozen_app_3.get(), perseus::state::ThawPrefs {\n                page: perseus::state::PageThawPrefs::IncludeAll,\n                global_prefer_frozen: true\n            }).unwrap();\n        })) { &quot;Thaw...&quot; }\n    }\n}\n\npub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {\n    Template::new(&quot;index&quot;)\n        .build_state_fn(get_build_state)\n        .template(index_page)\n}\n\n#[perseus::autoserde(build_state)]\npub async fn get_build_state(\n    _path: String,\n    _locale: String,\n) -&gt; RenderFnResultWithCause&lt;IndexProps&gt; {\n    Ok(IndexProps {\n        username: &quot;&quot;.to_string(),\n    })\n}\n\n</code></pre>\n<h2>Thawing</h2>\n<p>Recovering your app's state from a frozen state is called <em>thawing</em> in Perseus (basically like hydration for state, but remember that hydration is for views and thawing is for state!), and it can occur gradually and automatically once you provide Perseus a frozen state to use, which you can do by calling <code>.thaw()</code> on the render context (which you can get with <code>perseus::get_render_ctx!()</code>). How you store and retrieve frozen state is entirely up to you. For example, you could store the user's last state in a database and then fetch that when the user logs in, or you could store it in IndexedDB and have even logging in be covered by it (if authentication tokens are part of your global state). Note that thawing will also return the user to the page they were on when the state was thawed.</p>\n<p>One important thing to understand about thawing though is how Perseus decided what state to use for a template, because there can be up to three options. Every template that accepts state will have generated state that's provided to it from the generation processes on the server, but there could also be a frozen state and an active state (some state that's already been made reactive). The server-generated state is always the lowest priority, and it will be used if no active or frozen state is available. However, deciding between frozen and active state is more complicated. If only one is available, it will of course be used, but it both are available, the choice is yours. You can represent this choice through the <code>ThawPrefs</code> <code>struct</code>, which must be provided to a call to <code>.thaw()</code> as the second argument. This has two fields, one for page state, and another for global state. For global state, you can set the <code>global_prefers_frozen</code> field to <code>true</code> if you want to override active global state with a frozen one. For page state, you'll use <code>PageThawPrefs</code>, which can be set to <code>IncludeAll</code> (all pages will prefer frozen state), <code>Include(Vec&lt;String&gt;)</code> (the listed pages will prefer frozen state, all others will prefer active state), or <code>Exclude(Vec&lt;String&gt;)</code> (the listed pages will prefer active state, all others will prefer frozen state). There's no <code>ExcludeAll</code> option because that would defeat the entire purpose of thawing.</p>\n<p>It may at first be tempting to use <code>IncludeAll</code>, but this is an important UX decision that you should consider carefully. Using frozen state when active state isn't available is automatic, but preferring frozen state <em>over</em> active state translates to something like this: a user does some stuff, then state is thawed, everything they did at the start is gone and replaced with whatever they did in the previous session. This might be entirely reasonable in pages that can only be accessed after thawing is complete, but in pages that are accessible at all times, this could be extremely irritating to your users!</p>\n<details>\n<summary>Thawing isn't working...</summary>\n<p>It may seem sometimes like thawing has completely failed, and this is usually for one of two reasons.</p>\n<ol>\n<li>You're extracting the state of another page.</li>\n<li>You're getting the global state without having it as the second argument to your template function. (In other words, you're getting it manually through <code>perseus::get_render_ctx!().global_state.borrow()</code>).</li>\n</ol>\n<p>In the first case, the reasoning is simple. State thawing is a gradual process, so the state for a page won't be thawed until the user actually visits that page. This is why it's much better to use global state for state that needs to be shared between pages, and you should generally avoid extracting state from other pages.</p>\n<p>In the second case, the reason is similar. When you get the global state directly in this way, you bypass the thawing process altogether, meaning thawed state won't show up. If you need to access the global state, you should do it by making it the second argument to your template function (as documented <a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/state/global\">here</a>).</p>\n<p><em>Note: in a future version of Perseus, thawing logic may be altered so that direct access does become possible, but it's currently not.</em></p>\n</details>\n","current_version":"0.3.4","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"outdated"},"0.4.x":{"docs_rs":"0.4","git":"HEAD","state":"stable"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/intro\">Introduction</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/core-principles\">Core Principles</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/tutorials/hello-world\">Hello World!</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/tutorials/second-app\">Your Second App</a></li>\n</ul>\n<hr />\n<h1>Reference</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/perseus-app\"><code>PerseusApp</code></a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/define-app\"><code>define_app!</code></a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/views\">Writing Views</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/index-view\">The Index View</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/live-reloading\">Live Reloading</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/templates/intro\">Templates and Routing</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/templates/metadata-modification\">Modifying the <code>&lt;head&gt;</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/templates/setting-headers\">Modifying HTTP Headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/templates/router-state\">Listening to the Router</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/error-pages\">Error Pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/static-content\">Static Content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/i18n/intro\">Internationalization</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/i18n/defining\">Defining Translations</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/i18n/using\">Using Translations</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/i18n/translations-managers\">Translations Managers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/i18n/other-engines\">Other Translation Engines</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/strategies/intro\">Rendering Strategies</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/strategies/build-state\">Build State</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/strategies/build-paths\">Build Paths</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/strategies/request-state\">Request State</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/strategies/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/strategies/incremental\">Incremental Generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/strategies/amalgamation\">State Amalgamation</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/state/rx\">Reactive State</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/state/global\">Global State</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/state/freezing\">State Freezing</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/state/idb-freezing\">Freezing to IndexedDB</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/state/hsr\">Hot State Reloading (HSR)</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/cli\">CLI</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/ejecting\">Ejecting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/snooping\">Snooping</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/testing/intro\">Testing</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/testing/checkpoints\">Checkpoints</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/testing/fantoccini-basics\">Fantoccini Basics</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/testing/manual\">Manual Testing</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/server-communication\">Communicating with a Server</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/stores\">Stores</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/exporting\">Static Exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/intro\">Plugins</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/functional\">Functional Actions</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/control\">Control Actions</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/using\">Using Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/tinker\">The <code>tinker</code> Action</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/writing\">Writing Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/security\">Security Considerations</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/plugins/publishing\">Publishing Plugins</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/engines\">Engines</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/deploying/intro\">Deploying</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/deploying/serverful\">Server Deployment</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/deploying/serverless\">Serverless Deployment</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/deploying/size\">Optimizing Code Size</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/deploying/relative-paths\">Relative Paths</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/deploying/docker\">Docker Deployment</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/updating\">Migrating from v0.3.3</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/reference/pitfalls-and-bugs\">Common Pitfalls and Known Bugs</a></li>\n</ul>\n<hr />\n<h1>Advanced</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/advanced/intro\">Under the Hood</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/advanced/arch\">Architecture</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/advanced/initial-loads\">Initial Loads</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/advanced/subsequent-loads\">Subsequent Loads</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/advanced/routing\">Routing</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.3.4/advanced/route-announcer\">Route Announcer</a></li>\n</ul>\n<hr />\n<h1>Further Tutorials</h1>\n<ul>\n<li><a href=\"docs/tutorials/auth\">Authentication</a></li>\n</ul>\n","status":"Outdated","title":"State Freezing"},"head":"<title>State Freezing | Perseus Docs</title><link rel=stylesheet href=.perseus/static/styles/markdown.css><link rel=stylesheet href=.perseus/static/styles/docs_links_markdown.css><link rel=stylesheet href=.perseus/static/prism.css>"}