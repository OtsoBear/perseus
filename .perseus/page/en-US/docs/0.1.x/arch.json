{"state":{"content":"<h1>Architecture</h1>\n<p>Perseus is a complex system, and this page will aim to explain the basics in a beginner-friendly way. If you've already used similar frameworks from the JS world like NextJS, then some of this may be familiar to you. If you're having trouble following along, please <a href=\"https://github.com/framesurge/perseus/issues/new/choose\">open an issue</a> and ask us to clarify some sections, because this page in particular should be accessible to everyone. If you'd like more specific help, <a href=\"\">ask on Gitter</a>!</p>\n<h2>Templates and Pages</h2>\n<p>The core of Perseus is the idea of templates. When you create a Perseus app, what you're basically doing is telling Perseus how to compile your code into a series of <em>pages</em>. <strong>Each page has a unique URL on your final website.</strong> If you have a blog, and every post is stored as something like <code>post/title</code>, then each post would be a unique page.</p>\n<p>But this doesn't mean you have to write the code for every page individually! Perseus does this for you, and only asks you to write <em>templates</em>. A template can generate one page or many, and a great example of one would be a <code>post</code> template. Each template has a <em>root path</em>, which is essentially like the space on your website that that template controls. For example, a post template might control <code>/post</code>, meaning it can render pages at <code>/post</code>, <code>/post/test</code>, <code>/post/longer/path</code>, etc. In theory, a template could render pages outside its domain, but this would be a bad idea for structure, and makes your code difficult to understand.</p>\n<h3>State</h3>\n<p>What differentiates pages from templates is <em>state</em>, which tells a page how to fill out its template to give unique content. For example, our post template would probably have a <code>content</code> field in its state, and its pages would use that to render their unique content!</p>\n<p>In terms of writing code, a page's state is just a <code>struct</code> that can be serialized and deserialized with <a href=\"https://serde.rs\">Serde</a>.</p>\n<h2>Rendering Strategies</h2>\n<p>Each template has a rendering strategy, which it uses to create its pages. There are a number of rendering strategies in Perseus, each of which is documented in detail in its own section. What's important to understand for now is that there are two main ways a template can render pages, at <em>build time</em>, or at <em>request time</em>. If a template renders at build time, it generates the code for your pages when you build your app, which means you end up serving static pages. This is <em>really fast</em>. However, sometimes you need information specific to each request to render a page (e.g. an authentication token), and you can't render at build. Instead, you'd render at request time, which gives you access to information about the HTTP request a user sent for your page.</p>\n<p>Here's a list of Perseus' currently supported rendering strategies. These can all be combined, but some combinations make more sense than others.</p>\n<table><thead><tr><th>Strategy</th><th>Description</th><th>Type</th></tr></thead><tbody>\n<tr><td>Build paths</td><td>Generates a series of pages for a template</td><td>Build</td></tr>\n<tr><td>Build state</td><td>Generates page state</td><td>Build</td></tr>\n<tr><td>Request state</td><td>Generates page state</td><td>Request</td></tr>\n<tr><td>Revalidation</td><td>Rebuilds pages conditionally</td><td>Hybrid</td></tr>\n<tr><td>Incremental generation</td><td>Builds pages on-demand</td><td>Hybrid</td></tr>\n</tbody></table>\n<p>There are two <em>hybrid</em> strategies listed above. They're a little more complicated, and out of the scope of this page, but they operate at both build <em>and</em> request-time, allowing you to reap the benefits of both worlds!</p>\n<h2>Routing</h2>\n<p><em>This section describes how Perseus works under the hood. Skip it if you want.</em></p>\n<p>Perseus doesn't just host your pages at their URLs though. In fact, Perseus has a generic handler for <em>any URL</em>, which returns what we call the <em>app shell</em>. That's a concept from the single-page app (e.g. ReactJS), where your app always has a constant shell around it, and each page is loaded into that shell, making page transitions more seamless. Perseus adopts this as well, but with the added benefits of super-fast static rendering strategies and a more lightweight shell.</p>\n<p>The shell includes a router (courtesy of <a href=\"https://github.com/sycamore-rs/sycamore\">Sycamore</a>), which determines what page the user wants, and then sends a request to a special endpoint behind <code>/.perseus</code>. That then renders the page and returns some static HTML and the page's state.</p>\n","current_version":"0.1.x","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"outdated"},"0.4.x":{"docs_rs":"0.4","git":"HEAD","state":"stable"}},"sidebar_content":"<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/setup\">Setup</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/arch\">Architecture</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/tutorials/first_app/intro\">Building Your First App</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/tutorials/first_app/setup\">Installation and Setup</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/tutorials/first_app/template\">Writing Your First Template</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/tutorials/first_app/app\">Setting up the App Itself</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/cli\">CLI</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/templates\">Templates</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/routing\">Routing</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/error_pages\">Error Pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/strategies/intro\">Rendering Strategies</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/strategies/build_paths\">Build Paths</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/strategies/build_state\">Build State</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/strategies/request_state\">Request State</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/strategies/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/strategies/incremental\">Incremental generation</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/building\">Building</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/serving\">Serving</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/integrations/actix-web\">Actix Web Integration</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/0.1.x/config_managers\">Config Managers</a></li>\n</ul>\n","status":"Outdated","title":"Architecture"},"head":"<title>Architecture | Perseus Docs</title><link rel=stylesheet href=.perseus/static/styles/markdown.css><link rel=stylesheet href=.perseus/static/styles/docs_links_markdown.css><link rel=stylesheet href=.perseus/static/prism.css>"}