{"state":{"content":"<h1>Hydration</h1>\n<p>One of the most important parts of Perseus is its prerendering system, which allows it to turn Rust code that renders HTML into actual HTML ahead of time, making sure that your users see content immediately. However, there's an art to going from prerendered content to a functional webpage, and that art is <em>hydration</em>.</p>\n<p>Internally, Perseus does <em>a heck of a lot</em> in the prerendering process, but it eventually comes down to Sycamore's <code>render_to_string()</code> function (or, rather, an internal re-implementation of it with some tweaks), which inserts some little numbers throughout your HTML called <em>hydration IDs</em>. These allow Sycamore to then <em>hydrate</em> your page after an <em>initial load</em>.</p>\n<h2>Initial and subsequent loads</h2>\n<p>But, in order to really understand hydration, we need to understand a bit more about how Perseus handles routing. There are two distinct types of page loads in Perseus, which are handled <em>completely</em> differently.</p>\n<p>Initial loads are the first kind, and these occur when a user comes to a page on your site from somewhere else on the internet. For example, if someone searches up your site on Google and then clicks on the provided link, this would be an initial load. What makes these special is that the user has <em>absolutely nothing</em> about your site, which means they need to be sent what we call the <em>app shell</em>, which consists of a <code>bundle.js</code> file, and a <code>bundle.wasm</code> file, which will take over the responsibility of routing from the browser, making sure that future renders will be much faster. We'll get to that though. However, if we were just to do this, and then leave Perseus to render your site on the client-side, this would be a <em>terrible</em> loading experience, because it takes a moment to download a Wasm bundle and run it. In the interim period, the user would be staring at a blank page, waiting --- not good!</p>\n<p>So, Perseus bundles this together with an HTML file that's automatically generated. This will contain the prerendered version of whatever page the user has requested, meaning they can see some content <em>immediately</em>. The Wasm bundle can then take a moment to load in the background, and the code will be made interactive afterward. We'll get to what that means in a moment.</p>\n<p>However, once the user has loaded all that once, they don't need to get the app shell again, because it definitionally remains the same for every page. Therefore, Perseus only needs to fetch the state of the next page the user loads (along with its head metadata), because Rust is so darn fast at rendering HTML (it's actually slower to fetch an HTML fragment and then hydrate it for subsequent loads!), so it takes over from the browser at handling routing and minimizes the number of network requests performed. This also allows Perseus to do application-level caching, which dramatically improves performance when a user goes back to a page they've already visited (by &quot;improves performance&quot;, we mean it becomes <em>literally instantaneous</em>),</p>\n<p>And that's the difference between initial loads and subsequent ones! In initial loads, there's a whole package, and in subsequent loads, there's just the state of whatever page is being rendered next.</p>\n<h2>Hydration</h2>\n<p>As explained just now, Perseus <em>prerenders</em> your pages to HTML on the engine-side, as early as it can (usually at build-time, unless you're doing something that needs access to the user's request, like accessing cookies for check authentication). Unfortunately though, there's quite a gap between static HTML (which is literally a string) and an interactive page: that gap is <em>event handlers</em>. When a user pushes a button, the browser needs to know what to do, and that can't be encoded in stringified HTML.</p>\n<details>\n<summary>Yes it can be!</summary>\n<p>Okay, if you're used to using vanilla JavaScript, you might be recalling how you could write something like this:</p>\n<pre><code class=\"language-html\">&lt;button onclick=&quot;console.log('Clicked!')&quot;&gt;Click!&lt;/button&gt;\n</code></pre>\n<p>In this case, the event handler is absolutely encoded in the static HTML, but this doesn't play well with Wasm at all just yet. One day, hopefully, we'll be able to encode event handlers properly in static HTML, but this may actually be slower than the approach we're about to describe.</p>\n<p>You might also be familiar with a framework like <a href=\"https://qwik.builder.io\">Qwik</a>, which uses something called <em>resumability</em>, which translates to basically bringing framework complexities back to the basics of string Javascript inside HTML. Unfortunately, this isn't yet possible with Wasm. Perseus does the next-best thing.</p>\n</details>\n<p>The solution to this problem is <em>hydration</em>, where a program goes through the HTML string and checks it against your code, adding event handlers as it needs. This is quite a complex process very often, and it's part of Sycamore, not Perseus, so the credit for this should go entirely to them!</p>\n<p>If you're from JS-land, you might be used to hydration taking quite a while, during which time users can't click buttons or anything. Unlike JS, Wasm comes compiled, and can be executed piece-by-piece as the browser gets more of it from the server. This, plus the fact that Rust is just crazily fast, means Perseus (really Sycamore) does hydration practically instantly: the limiting factor is not hydration, but rather the size of the Wasm bundle, which influences how long it takes to download the whole thing, which is why it's important to optimize Wasm for size (which <code>perseus deploy</code> does automatically, and very aggressively).</p>\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"outdated"},"0.4.x":{"docs_rs":"0.4","git":"HEAD","state":"stable"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers\">Heads and headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation\">State amalgamation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\">Freezing and thawing</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/manual\">Manually implementing <code>ReactiveState</code></a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/using\">Using capsules</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-components\">Capsules vs. components</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Next","title":"Hydration"},"head":"<title>Hydration | Perseus Docs</title><link rel=stylesheet href=.perseus/static/styles/markdown.css><link rel=stylesheet href=.perseus/static/styles/docs_links_markdown.css><link rel=stylesheet href=.perseus/static/prism.css>"}