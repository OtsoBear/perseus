{"state":{"content":"<h1>Internationalization</h1>\n<p>One of the most useful features of Perseus for larger apps is its inbuilt support for <em>internationalization</em>, or <em>i18n</em> for short, which means making your app available in multiple languages. This is typically done by replacing all instances of human language in your code (e.g. the <code>Hello World!</code> string) with translation IDs, which are then resolved automatically to the correct text based on what <em>locale</em> the user is viewing the page in. Locales are defined in Perseus, as in other systems, as consisting of a language code and a region code: for example, <code>en-US</code> represents United States English, whereas <code>en-GB</code> represents British English. Note that this locale system is far from perfect, but it's currently a global standard, and it's used by browsers for declaring the preferred languages of their users.</p>\n<p>When you make your app available in multiple languages, Perseus will automatically take each of the locales you've specified and build every page in every single one of those locales (this will increase build times, but this is usually imperceptible, especially since everything is aggressively parallelized). Let's say your app is available in three languages: US English, Spanish, and French. This would mean your three locales might be <code>en-US</code>, <code>fr-FR</code>, and <code>es-ES</code> (<code>es</code> for Espa√±ol). This leads to Perseus taking your landing page (previously available at <code>/</code>), and localizing it to <code>/en-US/</code>, <code>/fr-FR/</code>, and <code>/es-ES/</code>. Similarly, your about page (formerly at <code>/about</code>) will become <code>/en-US/about</code>, <code>/fr-FR/about</code>, and <code>/es-ES/about</code>. You get the picture.</p>\n<p>But how do we know what language a user wants their pages in? Some sites figure this out by detecting what country you're in, to the peril of anyone using a VPN who slowly starts to learn Dutch against their will. The much better way of doing this is to just ask the browser, because users can configure their browsers with an arbitrary number of ordered locale preferences. For example, a Chinese native speaker who lives in Germany but is fluent in English might number her preferences as: <code>zh-CN</code>, <code>de-DE</code>, <code>en</code>, in that order. Notice the lack of a region code on the final preference (this is common). The process of <em>locale detection</em> is a complex one that requires comparing the languages an app has available with those a user would like to see. Unlike all other current frameworks, Perseus performs this process totally automatically according to web standards (see <a href=\"https://www.rfc-editor.org/rfc/rfc4647\">RFC 4647</a>). So, if our Chinese-German English speaker from before goes to <code>/about</code>, she will be redirected to <code>/en-US/about</code> automatically (since her first two preferences are unavailable). From here, any links will keep her in the <code>en-US</code> locale.</p>\n<p>You can set up internationalization in your app through <code>PerseusApp</code> like so:</p>\n<pre><code class=\"language-rust\">mod templates;\n\nuse perseus::prelude::*;\n\n#[perseus::main(perseus_axum::dflt_server)]\npub fn main&lt;G: Html&gt;() -&gt; PerseusApp&lt;G&gt; {\n    PerseusApp::new()\n        .template(crate::templates::index::get_template())\n        .template(crate::templates::about::get_template())\n        .template(crate::templates::post::get_template())\n        .error_views(ErrorViews::unlocalized_development_default())\n        .locales_and_translations_manager(&quot;en-US&quot;, &amp;[&quot;fr-FR&quot;, &quot;es-ES&quot;])\n}\n\n</code></pre>\n<h2>Translations</h2>\n<p>Translations in Perseus are handled through the <a href=\"https://docs.rs/perseus/0.4/perseus/i18n/trait.TranslationsManager.html\"><code>TranslationsManager</code></a> trait, which is described in further detail <a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\">here</a>, but you'll usually store them in a folder called <code>translations/</code> at the root of your project. The translator you're using will determine the format of these.</p>\n<p>In Perseus, translators are controlled by feature flags, which are mutually exclusive. Currently, there are just two: the <a href=\"https://projectfluent.org\">Fluent</a> translator, and the simple translator. The former uses <code>.ftl</code> files, which are a complex system of defining translations that can handle gender, pluralization, and all sorts of other linguistic difficulties, whereas the latter is a drop-dead-simple JSON file of translation IDs with very basic variable interpolation. Generally, it's recommended to only use the Fluent translator if you really need it, because it will add about 100kB of extra Wasm to your <code>bundle.wasm</code>, which will slow down initial loads a little (this is pre-compression, however). The Fluent translator is enabled by the <code>translator-fluent</code> feature flag, and the simple one corresponds to <code>translator-lightweight</code>.</p>\n<p>Take a look at <a href=\"https://github.com/framesurge/perseus/tree/main/examples/core/i18n\">this example</a> for how a full i18n-ed app looks (or you can take a look at the source code of this website!). Once you've defined some translation IDs, you can use them like so:</p>\n<pre><code class=\"language-rust\">use perseus::prelude::*;\nuse sycamore::prelude::*;\n\nfn index_page&lt;G: Html&gt;(cx: Scope) -&gt; View&lt;G&gt; {\n    let username = &quot;User&quot;;\n\n    view! { cx,\n        p { (t!(cx, &quot;hello&quot;, {\n            &quot;user&quot; = username\n        })) }\n        a(href = link!(cx, &quot;/about&quot;)) { &quot;About&quot; }\n    }\n}\n\npub fn get_template&lt;G: Html&gt;() -&gt; Template&lt;G&gt; {\n    Template::build(&quot;index&quot;).view(index_page).build()\n}\n\n</code></pre>\n<p>The critical point here is the use of <a href=\"https://docs.rs/perseus/0.4/perseus/prelude/macro.t.html\"><code>t!</code></a> macro, which takes in the render context and a translation ID, and outputs the localized version of the ID in the current locale (assuming it exists, otherwise it will panic). Variables can be interpolated by providing a third object, as shown in the above example.</p>\n<h2>Localized routing</h2>\n<p>To write an <code>href</code> or imperative routing call to another page in an app using i18n, you want to make sure you're going to the right locale, and not causing locale detection all over again. To do this, you can use the <a href=\"https://docs.rs/perseus/0.4/perseus/prelude/macro.link.html\"><code>link!</code></a> macro, which automatically prepends the correct locale.</p>\n<h2>Switching locales</h2>\n<p>Switching locales is actually incredibly easy: there's no context to update, or special subroutine to inform, you just navigate appropriately, and Perseus figures it out (because it's in charge of routing). By not using the <code>link!</code> macro, and instead navigating directly to a page like <code>/fr-FR/about</code>, users will be switched into the <code>fr-FR</code> locale, which the <code>link!</code> macro will then automatically apply after that.</p>\n<p>If you're using a component to perform locale switching (often included in the header or footer), you'll want to check what path a user is currently on so you switch the locale for the current page. This is typically done through a <code>Reactor</code> convenience method:</p>\n<pre><code class=\"language-rust\">Reactor::&lt;G&gt;::from_cx(cx).switch_locale(&quot;fr-FR&quot;)\n</code></pre>\n<p>Here, we're of course switching to <code>fr-FR</code>. This will implicitly involve a navigation and the fetching of the new translations.</p>\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"outdated"},"0.4.x":{"docs_rs":"0.4","git":"HEAD","state":"stable"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers\">Heads and headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation\">State amalgamation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\">Freezing and thawing</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/manual\">Manually implementing <code>ReactiveState</code></a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/using\">Using capsules</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-components\">Capsules vs. components</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Next","title":"Internationalization"},"head":"<title>Internationalization | Perseus Docs</title><link rel=stylesheet href=.perseus/static/styles/markdown.css><link rel=stylesheet href=.perseus/static/styles/docs_links_markdown.css><link rel=stylesheet href=.perseus/static/prism.css>"}