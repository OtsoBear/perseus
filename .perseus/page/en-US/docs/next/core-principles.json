{"state":{"content":"<h1>Core Principles</h1>\n<p>Before you dive into Perseus, you might want to get a better idea of the fundamentals on which the framework is built. If you'd prefer to dive straight in though, check out <a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">the tutorial</a>, and then maybe come back here later.</p>\n<p>The main key idea that underpins Perseus is about <em>templates</em>, and the primary architectural matter to understand is how Perseus apps actually work in terms of their components.</p>\n<h2>Templates</h2>\n<p>Templates are the key to understanding Perseus code. Once you do, you should be able to confidently write clear code for apps that do exactly what you want them to. Nicely, this core concept also correlates with the file of code that defines the majority of the inner workings of Perseus (which is 600 lines long...).</p>\n<p>There are two things you need to know about templates:</p>\n<ol>\n<li>An app is split into templates, and each template is split into pages.</li>\n<li>A page is generated from a template and state. <strong>Template + state = page</strong></li>\n</ol>\n<p>Anyone who's ever used a website before will be at least passingly familiar with the idea of <em>pages</em> --- they're things that display different content, each at a different route. For example, you might have a landing page at <code>https://example.com</code> and an about page at <code>https://example.com/about</code>.</p>\n<p>In Perseus, pages are never coded directly, they're generated by the engine from templates. Templates can be thought of as mathematical functions if you like: (crudely) a template <code>T</code> can be defined such that <code>T(x) = P</code>, where <code>x</code> is some state, and <code>P</code> is a page. </p>\n<p>Let's take an example to understand how this works in practice. Let's say you're building a music player app that has a vast library of songs (we'll ignore playlists, artists, etc. to keep things simple). The first step in designing your app is thinking about its structure. It comes fairly quickly that you'll need an index page to show the top songs, an about page to tell people about the platform, and one page for each song. Now, the index and about pages have different structures, but every song page has the same structure, just with different content. This is where templates come in. You would have one template for the index page and another for the about page, and then you'd have a third template for the songs pages.</p>\n<p>That third template can take in some state, and produce a different page for every single song, but all with the same structure. You can see this kind of concept in action on this very website. Every page in the docs has the same heading up the top, footer down the bottom, and sidebar on the left (or in a menu if you're on mobile), but they all have different content. There's just one template involved for all this, which generates hundreds of pages (here, that same template generates pages for every version of Perseus ever).</p>\n<p>So what about those first two? Well, they're very simple templates that don't take any state at all --- they can only produce one page. To take our crude mathematical definition, <code>T() = P</code> for these, and, since <code>T</code> takes no arguments, it can only produce the same page every time.</p>\n<p>This illustrates nicely that the determining factor that differentiates pages from each other is state, and that's what Perseus is built around.</p>\n<p>Let's return to our music player app. Are all those songs listed in a database available at build-time? Use the <a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\"><em>build state</em></a> strategy. Are there too many to build all at once? Use <a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\"><em>incremental generation</em></a> to build only the most commonly used songs first, and then build the rest on-demand when they're first accessed, caching to make them fast for subsequent users.</p>\n<p>Once that state is generated, Perseus will go right ahead and proactively prerender your pages to HTML, meaning your users see content the second they load your site. (This is called server-side rendering, except the actual rendering has happened ahead of time, whenever you built your app.)</p>\n<p>These ideas are built into Perseus at the core, and generating state for templates to generate pages is the fundamental idea behind Perseus. You'll find similar concepts in popular JavaScript frameworks like NextJS and GatsbyJS. It's Perseus' speed, ergonomics, and some things we'll explain in a moment that set it apart.</p>\n<p>Once you've generated some state and you've got all the pages ready, there's still a log of work to be done on this music player app. A given song might be paused or playing, the user might have manually turned off dark mode, autoplaying related songs might be on or off. This is all state, but it's not state that we can handle when we build your app. Traditionally, frameworks would leave you on your own here to work this all out, but Perseus tries to be a little more helpful by <em>automatically making your state reactive</em>. Let's say the state for a single song page includes the properties <code>name</code>, <code>artist</code>, <code>album</code>, <code>year</code>, and <code>paused</code> (there'd probably be a lot more in reality though!). The first four can be set at build time and forgotten about, but <code>paused</code> could be changed at any time. No problem, you can change it once the page is loaded. Just call <code>.set()</code> on it and Perseus will not only update it locally, but it will update it in a store global to your app so that, if a user goes back to that song later, it will be preserved (or not, your choice). And what about things like <code>dark_mode</code>, state that's relevant to the whole app? Well, Perseus provides inbuilt support for reactive global state that can be interacted with from any page.</p>\n<p>Now, if you're familiar with user interface (UI) development, this might all sound familiar to you, it's very similar to the <em>MVC</em>, or <em>model, view, controller</em> pattern. If you've never heard of this, it's just a way of developing apps in which you hold all the states that your app can possibly be in in a <em>model</em> and use that to build a <em>view</em>. Then you handle user interaction with a <em>controller</em>, which modifies the state, and the <em>view</em> updates accordingly. Perseus doesn't force this structure on you, and in fact you can opt out entirely from all this reactive state business if it's not your cup of tea with no problems, because Perseus doesn't use MVC as a <em>pattern</em> that you develop in, it uses it as an <em>architecture</em> that your code works in. You can use development patterns from 1960 or 2060 if you want, Perseus doesn't mind, it'll just work away in the background and make sure your app's state <em>just works</em>.</p>\n<p>Perseus also adds a little twist to the usual ideas of app state. If your entire app is represented in its state, then wouldn't it be cool if you could <em>freeze</em> that state, save it somewhere, and then boot it back up later to bring your app to exactly where it was before? This is inbuilt into Perseus, and it's still insanely fast. But, if you don't want it, you can turn it off, no problem.</p>\n<p>THis does let you do some really cool stuff though, like bringing a user back to exactly where they left off when they log back into your app, down to the last character they typed into an input, with only a few lines of code. (You store a string, Perseus handles the freezing and thawing.)</p>\n<h2>Architecture</h2>\n<p>When you write a Perseus app, you'll usually just define a <code>main()</code> function annotated with <code>#[perseus::main(...)]</code>, but this does some important things in the background. Specifically, it actually creates three functions: one that returns your <code>PerseusApp</code>, and then two new <code>main()</code> functions: one for the engine, and another for the browser. That distinction is one you should get used to, because it pervades Perseus. Unfortunately, most other frameworks try to shove this away behind some abstractions, which leads to confusing dynamics about where a function should actually be run. Perseus tries to make this as clear as possible.</p>\n<p>Before we can go any further into this though, we'll need to define the <em>engine</em>, because it's a Perseus-specific term. Usually, people would refer to the server-side, but this term was avoided for Perseus to make clear that the server is just a single part of the engine. The engine is made up of these components:</p>\n<ul>\n<li>Builder --- builds your app, generating some stuff in <code>dist/</code></li>\n<li>Exporter --- goes a few steps further than the builder, structuring your app for serving as a flat file structure, with no explicit server</li>\n<li>Server --- serves the built artifacts in <code>dist/</code>, executing certain server-side logic as necessary</li>\n<li>Error page exporter --- exports a single error page to a static file (e.g. you'll need this if you want your custom error pages to work on GitHub Pages or similar hosts)</li>\n<li>Tinker --- runs a certain type of plugin (more on this later)</li>\n</ul>\n<p>So, when we talk about <em>engine-side</em>, we mean this! The reason these are all lumped together is because they're all actually one binary, which is told what exact action to perform by a special environment variable automatically set by the CLI. So, when you run <code>perseus export</code> and <code>perseus serve</code>, those are actually <em>basically</em> both doing the exact same thing, just with a different environment variable setting!</p>\n<p>As for the browser-side, this is just the code that runs on the <code>wasm32-unknown-unknown</code> target (yes, those <code>unknown</code>s are supposed to be there!), which is Rust's way of talking about the browser.</p>\n<p>So, when we use the <code>#[perseus::main(...)]</code> macro, that's creating a function that returns your <code>PerseusApp</code>, and another called <code>main()</code> for the server (which is annotated with <code>#[tokio::main]</code> to make it asynchronous), and another called <code>main()</code> for the client (annotated with <code>#[wasm_bindgen::prelude::wasm_bindgen]</code> to make it discoverable by the browser).</p>\n<p>What's nice about this architecture is that you can do it yourself without the macro! In fact, if you want to do more advanced things, like setting up custom API routes, this is the best way to go. Then, you would use the <code>#[perseus::engine_main]</code> and <code>#[perseus::browser_main]</code> annotations to make your life easier. (Or, you could avoid them and do their work yourself, which is very straightforward.)</p>\n<p>The key thing here is that you can easily use this more advanced structure to gain greater control over your app, without sacrificing any performance. From here, you can also gain greater control over any part of your app's build process, which makes Perseus practically infinitely customizable to do exactly what you want!</p>\n<p>The upshot of all this is that Perseus is actually creating two separate entrypoints, one for the engine-side, and another for the browser-side. Crucially, both use the same <code>PerseusApp</code>, which is a universal way of defining your app's components, like templates. (You don't need to know this, but it actually does slightly different things on the browser and engine-sides itself to optimize your app.)</p>\n<p>Why do you need to know all this? Because it makes it much easier to understand how to expand your app's capabilities, and it demystifies those macros a bit. Also, it shows that you can actually avoid them entirely if you want to! (Sycamore also has a <a href=\"https://sycamore-rs.netlify.app/docs/basics/view#builder-syntax\">builder API</a> that you can use to avoid their <code>view! { .. }</code> macro too, if you really want.)</p>\n<p>One more thing to briefly note is about the <code>dist/target_wasm/</code> and <code>dist/target_engine/</code> directories. As you might have inferred, the purpose of this is to provide a separate compilation space for Wasm code, which is used under the hood by the CLI whenever it builds your app to Wasm. The reason for this is so that we can build the engine and the browser sides in parallel. With only one <code>target/</code> directory, Cargo would make us wait until one had completed before starting the other, which slows down compilation. In testing, there tends to be a significant reduction in compilation times as a result of this separation of targets.</p>\n<p>Finally, note that the Perseus CLI will automatically install the <code>wasm-bindgen</code> and <code>wasm-opt</code> CLIs in a system-wide cache (see <a href=\"https://docs.rs/directories/latest/directories/struct.ProjectDirs.html#method.cache_dir\">here</a> for how that's calculated), or in <code>dist/tools/</code> if that fails (there's an option to ensure the local cache is used as well, which you might want to set for more reproducible builds).</p>\n","current_version":"next","manifest":{"0.1.x":{"docs_rs":"0.1","git":"v0.1.4","state":"outdated"},"0.2.x":{"docs_rs":"0.2","git":"v0.2.3","state":"outdated"},"0.3.0-0.3.3":{"docs_rs":"0.3.3","git":"v0.3.3","state":"outdated"},"0.3.4":{"docs_rs":"0.3","git":"v0.3.6","state":"outdated"},"0.4.x":{"docs_rs":"0.4","git":"HEAD","state":"stable"}},"sidebar_content":"<h1>Introduction</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/quickstart\">Quickstart</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/what-is-perseus\">What is Perseus?</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/core-principles\">Core Principles</a></li>\n</ul>\n<h1>Your First App</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/installation\">Installing Perseus</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/defining\">Defining your app</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/generating-pages\">Generating pages</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/dev-cycle\">Development cycle</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/error-handling\">Error handling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/first-app/deploying\">Deploying your app</a></li>\n</ul>\n<h1>Fundamentals</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/perseus-app\"><code>PerseusApp</code></a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/reactor\">The reactor</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/routing\">Routing and navigation</a>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/preloading\">Preloading</a></li>\n</ul>\n</li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/i18n\">Internationalization</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/error-views\">Error views</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/hydration\">Hydration</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/static-content\">Static content</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/head-headers\">Heads and headers</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/styling\">Styling</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/js-interop\">Working with JS</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/serving-exporting\">Servers and exporting</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/debugging\">Debugging</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/testing\">Writing tests</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/plugins\">Plugins</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/fundamentals/compilation-times\">Improving Compilation Times</a></li>\n</ul>\n<h1>The State Platform</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/intro\">Understanding state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/build\">Build-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/request\">Request-time state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/revalidation\">Revalidation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/incremental\">Incremental generation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/amalgamation\">State amalgamation</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/browser\">Using state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/global\">Global state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/helper\">Helper state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/suspense\">Suspended state</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/freezing-thawing\">Freezing and thawing</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/state/manual\">Manually implementing <code>ReactiveState</code></a></li>\n</ul>\n<h1>Capsules</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/intro\">Introduction</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/using\">Using capsules</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/capsules/capsules-vs-components\">Capsules vs. components</a></li>\n</ul>\n<h1>Miscellaneous</h1>\n<ul>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/migrating\">Migrating from v0.3.x</a></li>\n<li><a href=\"https://framesurge.sh/perseus/en-US/docs/next/faq\">Common pitfalls and FAQs</a></li>\n</ul>\n","status":"Next","title":"Core Principles"},"head":"<title>Core Principles | Perseus Docs</title><link rel=stylesheet href=.perseus/static/styles/markdown.css><link rel=stylesheet href=.perseus/static/styles/docs_links_markdown.css><link rel=stylesheet href=.perseus/static/prism.css>"}